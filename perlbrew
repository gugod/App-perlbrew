#!/usr/bin/perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/perlbrew.pm"} = <<'APP_PERLBREW';
  package App::perlbrew;use strict;use warnings;use 5.008;our$VERSION="0.53";use Config;use Capture::Tiny;use Getopt::Long ();use File::Spec::Functions qw(catfile catdir);use File::Basename;use File::Path::Tiny;use FindBin;use CPAN::Perl::Releases;our$CONFIG;our$PERLBREW_ROOT=$ENV{PERLBREW_ROOT}|| catdir($ENV{HOME},"perl5","perlbrew");our$PERLBREW_HOME=$ENV{PERLBREW_HOME}|| catdir($ENV{HOME},".perlbrew");local$SIG{__DIE__}=sub {my$message=shift;warn$message;exit(1)};sub root {my ($self,$new_root)=@_;if (defined($new_root)){$self->{root}=$new_root}return$self->{root}|| $PERLBREW_ROOT}sub current_perl {my ($self,$v)=@_;$self->{current_perl}=$v if$v;return$self->{current_perl}|| $self->env('PERLBREW_PERL')|| ''}sub current_lib {my ($self,$v)=@_;$self->{current_lib}=$v if$v;return$self->{current_lib}|| $self->env('PERLBREW_LIB')|| ''}sub mkpath {File::Path::Tiny::mk(@_)}sub rmpath {File::Path::Tiny::rm(@_)}sub uniq(@) {my%a;grep {++$a{$_}==1}@_}sub min(@) {my@a=@_;my$m=$a[0];for my$x (@a){$m=$x if$x < $m}return$m}{my@command;sub http_get {my ($url,$header,$cb)=@_;if (ref($header)eq 'CODE'){$cb=$header;$header=undef}if (!@command){my@commands=([qw(curl --silent --location --fail --insecure)],[qw(fetch -o -)],[qw(wget --no-check-certificate --quiet -O -)],);for my$command (@commands){my$program=$command->[0];my$code=system("$program --version >/dev/null 2>&1")>> 8;if ($code!=127){@command=@$command;last}}die "You have to install either curl or wget\n" unless@command}open my$fh,'-|',@command,$url or die "open() for '@command $url': $!";local $/;my$body=<$fh>;close$fh;die 'Page not retrieved; HTTP error code 400 or above.' if$command[0]eq 'curl' and $? >> 8==22;die 'Page not retrieved: fetch failed.' if$command[0]eq 'fetch' and $?;die 'Server issued an error response.' if$command[0]eq 'wget' and $? >> 8==8;return$cb ? $cb->($body): $body}}sub perl_version_to_integer {my$version=shift;my@v=split(/[\.\-_]/,$version);if ($v[1]<= 5){$v[2]||=9;$v[3]=0}else {$v[3]||=9;$v[3]=~ s/[^0-9]//g}return$v[0]*10000000 + $v[1]*10000 + $v[2]*10 + $v[3]}sub new {my($class,@argv)=@_;my%opt=(original_argv=>\@argv,force=>0,quiet=>0,D=>[],U=>[],A=>[],sitecustomize=>'',);local (@ARGV)=@argv;Getopt::Long::Configure('pass_through','no_ignore_case','bundling',);Getopt::Long::GetOptions(\%opt,'force|f!','notest|n!','quiet|q!','verbose|v','as=s','help|h','version','root=s','D=s@','U=s@','A=s@','j=i','sitecustomize=s',)or run_command_help(1);$opt{args}=\@ARGV;for my$flags (@opt{qw(D U A)}){for my$value(@{$flags}){$value =~ s/^=//}}return bless \%opt,$class}sub env {my ($self,$name)=@_;return$ENV{$name}if$name;return \%ENV}sub path_with_tilde {my ($self,$dir)=@_;my$home=$self->env('HOME');$dir =~ s/^$home/~/ if$home;return$dir}sub is_shell_csh {my ($self)=@_;return 1 if$self->env('SHELL')=~ /(t?csh)/;return 0}sub run {my($self)=@_;$self->run_command($self->args)}sub args {my ($self)=@_;return @{$self->{args}}}sub commands {my ($self)=@_;my$package=ref$self ? ref$self : $self;my@commands;my$symtable=do {no strict 'refs';\%{$package .'::'}};for my$sym (keys %$symtable){if($sym =~ /^run_command_/){my$glob=$symtable->{$sym};if(defined *$glob{CODE}){$sym =~ s/^run_command_//;$sym =~ s/_/-/g;push@commands,$sym}}}return@commands}sub editdist {my@a=split //,shift;my@b=split //,shift;my@d;$d[$_][0]=$_ for (0 .. @a);$d[0][$_]=$_ for (0 .. @b);for my$i (1 .. @a){for my$j (1 .. @b){$d[$i][$j]=($a[$i-1]eq $b[$j-1]? $d[$i-1][$j-1]: 1 + min($d[$i-1][$j],$d[$i][$j-1],$d[$i-1][$j-1]))}}return$d[@a][@b]}sub find_similar_commands {my ($self,$command)=@_;my$SIMILAR_DISTANCE=6;my@commands=sort {$a->[1]<=> $b->[1]}grep {defined}map {my$d=editdist($_,$command);($d < $SIMILAR_DISTANCE)? [$_,$d ]: undef}$self->commands;if(@commands){my$best=$commands[0][1];@commands=map {$_->[0]}grep {$_->[1]==$best}@commands}return@commands}sub download {my ($self,$url,$path,$on_error)=@_;my$mirror=$self->config->{mirror};my$header=$mirror ? {'Cookie'=>"cpan=$mirror->{url}"}: undef;open my$BALL,">",$path or die "Failed to open $path for writing.\n";http_get($url,$header,sub {my ($body)=@_;unless ($body){if (ref($on_error)eq 'CODE'){$on_error->($url)}else {die "ERROR: Failed to download $url.\n"}}print$BALL $body});close$BALL}sub run_command {my ($self,$x,@args)=@_;my$command=$x;if($self->{version}){$x='version'}elsif(!$x){$x='help';@args=(0,$self->{help}? 2 : 0)}elsif($x eq 'help'){@args=(0,2)unless@args}my$s=$self->can("run_command_$x");unless ($s){$x =~ y/-/_/;$s=$self->can("run_command_$x")}unless($s){my@commands=$self->find_similar_commands($x);if(@commands > 1){@commands=map {'    ' .$_}@commands;die "Unknown command: `$command`. Did you mean one of the following?\n" .join("\n",@commands)."\n"}elsif(@commands==1){die "Unknown command: `$command`. Did you mean `$commands[0]`?\n"}else {die "Unknown command: `$command`. Typo?\n"}}if ($x eq 'install'){$args[0]=~ s/\A((?:\d+\.)*\d+)\Z/perl-$1/ if@args}$self->$s(@args)}sub run_command_version {my ($self)=@_;my$package=ref$self;my$version=$self->VERSION;print "$0  - $package/$version\n"}sub run_command_help {my ($self,$status,$verbose)=@_;require Pod::Usage;if ($status &&!defined($verbose)){if ($self->can("run_command_help_${status}")){$self->can("run_command_help_${status}")->($self)}else {my$out="";open my$fh,">",\$out;Pod::Usage::pod2usage(-exitval=>"NOEXIT",-verbose=>99,-sections=>"COMMAND: " .uc($status),-output=>$fh,-noperldoc=>1);$out =~ s/\A[^\n]+\n//s;$out =~ s/^    //gm;if ($out =~ /\A\s*\Z/){$out="Cannot find documentation for '$status'\n\n"}print "\n$out";close$fh}}else {Pod::Usage::pod2usage(-noperldoc=>1,-verbose=>$verbose||0,-exitval=>(defined$status ? $status : 1))}}my%comp_installed=(use=>1,switch=>1,);sub run_command_compgen {my($self,$cur,@args)=@_;$cur=0 unless defined($cur);if($self->env('PERLBREW_DEBUG_COMPLETION')){open my$log,'>>','bashcomp.log';print$log "[$$] $cur of [@args]\n"}my$subcommand=$args[1];my$subcommand_completed=($cur >= 2);if(!$subcommand_completed){$self->_compgen($subcommand,$self->commands)}else {if($comp_installed{$subcommand}){if($cur <= 2){my$part;if(defined($part=$args[2])){$part=qr/ \Q$part\E /xms}$self->_compgen($part,map{$_->{name}}$self->installed_perls())}}elsif($subcommand eq 'help'){if($cur <= 2){$self->_compgen($args[2],$self->commands())}}else {}}}sub _compgen {my($self,$part,@reply)=@_;if(defined$part){$part=qr/\A \Q$part\E /xms if ref($part)ne ref(qr//);@reply=grep {/$part/}@reply}for my$word(@reply){print$word,"\n"}}sub run_command_available {my ($self,$dist,$opts)=@_;my@available=$self->available_perls(@_);my@installed=$self->installed_perls(@_);my$is_installed;for my$available (@available){$is_installed=0;for my$installed (@installed){my$name=$installed->{name};my$cur=$installed->{is_current};if ($available eq $installed->{name}){$is_installed=1;last}}print$is_installed ? 'i ' : '  ',$available,"\n"}}sub available_perls {my ($self,$dist,$opts)=@_;my$url="http://www.cpan.org/src/README.html";my$html=http_get($url,undef,undef);unless($html){die "\nERROR: Unable to retrieve the list of perls.\n\n"}my@available_versions;for (split "\n",$html){push@available_versions,$1 if m|<td><a href="http://www.cpan.org/src/.+?">(.+?)</a></td>|}s/\.tar\.gz// for@available_versions;return@available_versions}sub perl_release {my ($self,$version)=@_;my$tarballs=CPAN::Perl::Releases::perl_tarballs($version);my$x=(values %$tarballs)[0];if ($x){my$dist_tarball=(split("/",$x))[-1];my$dist_tarball_url="http://search.cpan.org/CPAN/authors/id/$x";return ($dist_tarball,$dist_tarball_url)}my$mirror=$self->config->{mirror};my$header=$mirror ? {'Cookie'=>"cpan=$mirror->{url}"}: undef;my$html=http_get("http://search.cpan.org/dist/perl-${version}",$header);unless ($html){die "ERROR: Failed to download perl-${version} tarball."}my ($dist_path,$dist_tarball)=$html =~ m[<a href="(/CPAN/authors/id/.+/(perl-${version}.tar.(gz|bz2)))">Download</a>];die "ERROR: Cannot find the tarball for perl-$version\n" if!$dist_path and!$dist_tarball;my$dist_tarball_url="http://search.cpan.org${dist_path}";return ($dist_tarball,$dist_tarball_url)}sub run_command_init {my$self=shift;my@args=@_;my$HOME=$self->env('HOME');mkpath($_)for (grep {!-d $_}map {catdir($self->root,$_)}qw(perls dists build etc bin));if (@args && $args[0]eq '-'){if ($self->is_shell_csh){}else {$self->run_command_init_in_bash}exit 0}open my$bashrc,">",catfile($self->root,"etc","bashrc");print$bashrc BASHRC_CONTENT();close$bashrc;open my$bash_completion,">",catfile($self->root,"etc","perlbrew-completion.bash");print$bash_completion BASH_COMPLETION_CONTENT();close$bash_completion;open my$csh_wrapper,">",catfile($self->root,"etc","csh_wrapper");print$csh_wrapper CSH_WRAPPER_CONTENT();close$csh_wrapper;open my$csh_reinit,">",catfile($self->root,"etc","csh_reinit");print$csh_reinit CSH_REINIT_CONTENT();close$csh_reinit;open my$csh_set_path,">",catfile($self->root,"etc","csh_set_path");print$csh_set_path CSH_SET_PATH_CONTENT();close$csh_set_path;open my$cshrc,">",catfile($self->root,"etc","cshrc");print$cshrc CSHRC_CONTENT();close$cshrc;my ($shrc,$yourshrc);if ($self->is_shell_csh){$shrc='cshrc';$self->env("SHELL")=~ m/(t?csh)/;$yourshrc=$1 ."rc"}elsif ($self->env("SHELL")=~ m/zsh$/){$shrc="bashrc";$yourshrc='zshenv'}else {$shrc="bashrc";$yourshrc="bash_profile"}my$root_dir=$self->path_with_tilde($self->root);my$pb_home_dir=$self->path_with_tilde($PERLBREW_HOME);my$code=qq(    source $root_dir/etc/${shrc});if ($PERLBREW_HOME ne catdir($ENV{HOME},".perlbrew")){$code="    export PERLBREW_HOME=$pb_home_dir\n" .$code}print <<INSTRUCTION}sub run_command_init_in_bash {print BASHRC_CONTENT()}sub run_command_self_install {my$self=shift;my$executable=$0;unless (File::Spec->file_name_is_absolute($executable)){$executable=File::Spec->rel2abs($executable)}my$target=catfile($self->root,"bin","perlbrew");if ($executable eq $target){print "You are already running the installed perlbrew:\n\n    $executable\n";exit}mkpath(catdir($self->root,"bin"));open my$fh,"<",$executable;my@lines=<$fh>;close$fh;$lines[0]=$self->system_perl_shebang ."\n";open$fh,">",$target;print$fh $_ for@lines;close$fh;chmod(0755,$target);my$path=$self->path_with_tilde($target);print "perlbrew is installed: $path\n" unless$self->{quiet};$self->run_command_init();return}sub do_install_git {my$self=shift;my$dist=shift;my$dist_name;my$dist_git_describe;my$dist_version;require Cwd;my$cwd=Cwd::cwd();chdir$dist;if (`git describe` =~ /v((5\.\d+\.\d+(?:-RC\d)?)(-\d+-\w+)?)$/){$dist_name='perl';$dist_git_describe="v$1";$dist_version=$2}chdir$cwd;my$dist_extracted_dir=File::Spec->rel2abs($dist);$self->do_install_this($dist_extracted_dir,$dist_version,"$dist_name-$dist_version");return}sub do_install_url {my$self=shift;my$dist=shift;my$dist_name='perl';my ($dist_version)=$dist =~ m/-([\d.]+(?:-RC\d+)?|git)\./;my ($dist_tarball)=$dist =~ m{/([^/]*)$};my$dist_tarball_path=catfile($self->root,"dists",$dist_tarball);my$dist_tarball_url=$dist;$dist="$dist_name-$dist_version";if ($dist_tarball_url =~ m/^file/){print "Installing $dist from local archive $dist_tarball_url\n";$dist_tarball_url =~ s/^file:\/+/\//;$dist_tarball_path=$dist_tarball_url}else {print "Fetching $dist as $dist_tarball_path\n";$self->download($dist_tarball_url,$dist_tarball_path)}my$dist_extracted_path=$self->do_extract_tarball($dist_tarball_path);$self->do_install_this($dist_extracted_path,$dist_version,$dist);return}sub do_extract_tarball {my$self=shift;my$dist_tarball=shift;my$tarx=($^O eq 'solaris' ? 'gtar ' : 'tar ').($dist_tarball =~ m/bz2$/ ? 'xjf' : 'xzf');my$extract_command="cd @{[ $self->root ]}/build; $tarx $dist_tarball";die "Failed to extract $dist_tarball" if system($extract_command);$dist_tarball =~ s{.*/([^/]+)\.tar\.(?:gz|bz2)$}{$1};return "@{[ $self->root ]}/build/$dist_tarball"}sub do_install_blead {my$self=shift;my$dist=shift;my$dist_name='perl';my$dist_git_describe='blead';my$dist_version='blead';my$dist_tarball='blead.tar.gz';my$dist_tarball_path=catfile($self->root,"dists",$dist_tarball);print "Fetching $dist_git_describe as $dist_tarball_path\n";$self->download("http://perl5.git.perl.org/perl.git/snapshot/$dist_tarball",$dist_tarball_path,sub {die "\nERROR: Failed to download perl-blead tarball.\n\n"});$self->do_extract_tarball($dist_tarball_path);my$build_dir=catdir($self->root,"build");local*DIRH;opendir DIRH,$build_dir or die "Couldn't open ${build_dir}: $!";my@contents=readdir DIRH;closedir DIRH or warn "Couldn't close ${build_dir}: $!";my@candidates=grep {m/^perl-[0-9a-f]{7,8}$/}@contents;@candidates=map {$_->[0]}sort {$b->[1]<=> $a->[1]}map {[$_,(stat(catdir($build_dir,$_)))[9]]}@candidates;my$dist_extracted_dir=catdir($self->root,"build",$candidates[0]);$self->do_install_this($dist_extracted_dir,$dist_version,"$dist_name-$dist_version");return}sub do_install_release {my$self=shift;my$dist=shift;my ($dist_name,$dist_version)=@_;my ($dist_tarball,$dist_tarball_url)=$self->perl_release($dist_version);my$dist_tarball_path=catfile($self->root,"dists",$dist_tarball);if (-f $dist_tarball_path){print "Use the previously fetched ${dist_tarball}\n" if$self->{verbose}}else {print "Fetching $dist_name $dist_version as $dist_tarball_path\n" unless$self->{quiet};$self->download($dist_tarball_url,$dist_tarball_path)}my$dist_extracted_path=$self->do_extract_tarball($dist_tarball_path);$self->do_install_this($dist_extracted_path,$dist_version,$dist);return}sub run_command_install {my ($self,$dist,$opts)=@_;unless($dist){$self->run_command_help("install");exit(-1)}$self->{dist_name}=$dist;my$installation_name=$self->{as}|| $dist;if ($self->is_installed($installation_name)&&!$self->{force}){die "\nABORT: $installation_name is already installed.\n\n"}my$help_message="Unknown installation target \"$dist\", abort.\nPlease see `perlbrew help` for the instruction on using the install command.\n\n";my ($dist_name,$dist_version)=$dist =~ m/^(perl)-?([\d._]+(?:-RC\d+)?|git)$/;if (!$dist_name ||!$dist_version){if (-d "$dist/.git"){$self->do_install_git($dist)}if (-f $dist){$self->do_install_archive($dist)}elsif ($dist =~ m/^(?:https?|ftp|file)/){$self->do_install_url($dist)}elsif ($dist =~ m/(?:perl-)?blead$/){$self->do_install_blead($dist)}else {die$help_message}}elsif ($dist_name eq 'perl'){$self->do_install_release($dist,$dist_name,$dist_version)}else {die$help_message}return}sub run_command_download {my ($self,$dist)=@_;my ($dist_name,$dist_version)=$dist =~ m/^(.*)-([\d.]+(?:-RC\d+)?)$/;my ($dist_tarball,$dist_tarball_url)=$self->perl_release($dist_version);my$dist_tarball_path=catfile($self->root,"dists",$dist_tarball);if (-f $dist_tarball_path &&!$self->{force}){print "$dist_tarball already exists\n"}else {print "Fetching $dist as $dist_tarball_path\n" unless$self->{quiet};$self->download($dist_tarball_url,$dist_tarball_path)}}sub purify {my ($self,$envname)=@_;my@paths=grep {index($_,$PERLBREW_HOME)< 0 && index($_,$self->root)< 0}split /:/,$self->env($envname);return wantarray ? @paths : join(":",@paths)}sub system_perl_path {my ($self)=@_;my$system_perl_path=do {local$ENV{PATH}=$self->pristine_path;`perl -MConfig -e 'print \$Config{perlpath}'`};return$system_perl_path}sub system_perl_shebang {my ($self)=@_;return$Config{sharpbang}.$self->system_perl_path}sub pristine_path {my ($self)=@_;return$self->purify("PATH")}sub pristine_manpath {my ($self)=@_;return$self->purify("MANPATH")}sub run_command_display_system_perl_path {print $_[0]->system_perl_path ."\n"}sub run_command_display_system_perl_shebang {print $_[0]->system_perl_shebang ."\n"}sub run_command_display_pristine_path {print $_[0]->pristine_path ."\n"}sub run_command_display_pristine_manpath {print $_[0]->pristine_manpath ."\n"}sub do_install_archive {my$self=shift;my$dist_tarball_path=shift;my$dist_version;my$installation_name;if (basename($dist_tarball_path)=~ m{perl-?(5.+)\.tar\.(gz|bz2)\Z}){$dist_version=$1;$installation_name="perl-${dist_version}"}unless ($dist_version && $installation_name){die "Unable to determine perl version from archive filename.\n\nThe archive name should look like perl-5.x.y.tar.gz or perl-5.x.y.tar.bz2\n"}my$dist_extracted_path=$self->do_extract_tarball($dist_tarball_path);$self->do_install_this($dist_extracted_path,$dist_version,$installation_name);return}sub do_install_this {my ($self,$dist_extracted_dir,$dist_version,$installation_name)=@_;$self->{log_file}||=catfile($self->root,"build.${installation_name}.log");my@d_options=@{$self->{D}};my@u_options=@{$self->{U}};my@a_options=@{$self->{A}};my$sitecustomize=$self->{sitecustomize};$installation_name=$self->{as}if$self->{as};if ($sitecustomize){die "Could not read sitecustomize file '$sitecustomize'\n" unless -r $sitecustomize;push@d_options,"usesitecustomize"}my$perlpath=$self->root ."/perls/$installation_name";my$patchperl=$self->root ."/bin/patchperl";unless (-x $patchperl && -f _){$patchperl="patchperl"}unshift@d_options,qq(prefix=$perlpath);push@d_options,"usedevel" if$dist_version =~ /5\.1[13579]|git|blead/;unless (grep {/eval:scriptdir=/}@a_options){push@a_options,"'eval:scriptdir=${perlpath}/bin'"}print "Installing $dist_extracted_dir into " .$self->path_with_tilde("@{[ $self->root ]}/perls/$installation_name")."\n\n";print <<INSTALL if!$self->{verbose};my@preconfigure_commands=("cd $dist_extracted_dir","rm -f config.sh Policy.sh",$patchperl,);my$configure_flags=$self->env("PERLBREW_CONFIGURE_FLAGS")|| '-de';my@configure_commands=("sh Configure $configure_flags " .join(' ',(map {qq{'-D$_'}}@d_options),(map {qq{'-U$_'}}@u_options),(map {qq{'-A$_'}}@a_options),),$dist_version =~ /^5\.(\d+)\.(\d+)/ && ($1 < 8 || $1==8 && $2 < 9)? ("$^X -i -nle 'print unless /command-line/' makefile x2p/makefile"): ());my@build_commands=("make " .($self->{j}? "-j$self->{j}" : ""));my$test_target="test";if ($dist_version =~ /^5\.(\d+)\.(\d+)/ && ($1 >= 8 || $1==7 && $2==3)){$test_target="test_harness"}local$ENV{TEST_JOBS}=$self->{j}if$test_target eq "test_harness" && ($self->{j}||1)> 1;my@install_commands=$self->{notest}? "make install" : ("make $test_target","make install");@install_commands=join " && ",@install_commands unless($self->{force});my$cmd=join " && ",(@preconfigure_commands,@configure_commands,@build_commands,@install_commands);unlink($self->{log_file});if($self->{verbose}){$cmd="($cmd) 2>&1 | tee $self->{log_file}";print "$cmd\n" if$self->{verbose}}else {$cmd="($cmd) >> '$self->{log_file}' 2>&1 "}delete$ENV{$_}for qw(PERL5LIB PERL5OPT);if ($self->do_system($cmd)){my$newperl=catfile($self->root,"perls",$installation_name,"bin","perl");unless (-e $newperl){$self->run_command_symlink_executables($installation_name)}if ($sitecustomize){my$capture=$self->do_capture("$newperl -V:sitelib");my ($sitelib)=$capture =~ /sitelib='(.*)';/;mkpath($sitelib)unless -d $sitelib;my$target="$sitelib/sitecustomize.pl";open my$dst,">",$target or die "Could not open '$target' for writing: $!\n";open my$src,"<",$sitecustomize or die "Could not open '$sitecustomize' for reading: $!\n";print {$dst}do {local $/;<$src>}}print "$installation_name is successfully installed.\n"}else {die <<FAIL}return}sub do_install_program_from_url {my ($self,$url,$program_name,$body_filter)=@_;my$out=$self->root ."/bin/" .$program_name;if (-f $out &&!$self->{force}){require ExtUtils::MakeMaker;my$ans=ExtUtils::MakeMaker::prompt("\n$out already exists, are you sure to override ? [y/N]","N");if ($ans !~ /^Y/i){print "\n$program_name installation skipped.\n\n" unless$self->{quiet};return}}my$body=http_get($url)or die "\nERROR: Failed to retrieve $program_name executable.\n\n";if ($body_filter && ref($body_filter)eq "CODE"){$body=$body_filter->($body)}mkpath("@{[ $self->root ]}/bin")unless -d "@{[ $self->root ]}/bin";open my$OUT,'>',$out or die "cannot open file($out): $!";print$OUT $body;close$OUT;chmod 0755,$out;print "\n$program_name is installed to\n\n    $out\n\n" unless$self->{quiet}}sub do_system {my ($self,@cmd)=@_;return!system(@cmd)}sub do_capture {my ($self,$cmd)=@_;return Capture::Tiny::capture {$self->do_system($cmd)}}sub format_perl_version {my$self=shift;my$version=shift;return sprintf "%d.%d.%d",substr($version,0,1),substr($version,2,3),substr($version,5)}sub installed_perls {my$self=shift;my@result;my$root=$self->root;for (<$root/perls/*>){my ($name)=$_ =~ m/\/([^\/]+$)/;my$executable=catfile($_,'bin','perl');push@result,{name=>$name,version=>$self->format_perl_version(`$executable -e 'print \$]'`),is_current=>($self->current_perl eq $name)&&!$self->env("PERLBREW_LIB"),libs=>[$self->local_libs($name)]}}return@result}sub local_libs {my ($self,$perl_name)=@_;my@libs=map {substr($_,length($PERLBREW_HOME)+ 6)}<$PERLBREW_HOME/libs/*>;if ($perl_name){@libs=grep {/^$perl_name\@/}@libs}my$current=$self->current_perl .'@' .($self->env("PERLBREW_LIB")|| '');@libs=map {my ($p,$l)=split(/@/,$_);+{name=>$_,is_current=>$_ eq $current,perl_name=>$p,lib_name=>$l }}@libs;return@libs}sub is_installed {my ($self,$name)=@_;return grep {$name eq $_->{name}}$self->installed_perls}sub perlbrew_env {my ($self,$name)=@_;my ($perl_name,$lib_name);if ($name){($perl_name,$lib_name)=$self->resolve_installation_name($name);unless ($perl_name){die "\nERROR: The installation \"$name\" is unknown.\n\n"}}my%env=(PERLBREW_VERSION=>$VERSION,PERLBREW_PATH=>catdir($self->root,"bin"),PERLBREW_MANPATH=>"",PERLBREW_ROOT=>$self->root);if ($perl_name){if(-d "@{[ $self->root ]}/perls/$perl_name/bin"){$env{PERLBREW_PERL}=$perl_name;$env{PERLBREW_PATH}.= ":" .catdir($self->root,"perls",$perl_name,"bin");$env{PERLBREW_MANPATH}=catdir($self->root,"perls",$perl_name,"man")}if ($lib_name){require local::lib;if ($ENV{PERL_LOCAL_LIB_ROOT}&& $ENV{PERL_LOCAL_LIB_ROOT}=~ /^$PERLBREW_HOME/){my%deactivate_env=local::lib->build_deact_all_environment_vars_for($ENV{PERL_LOCAL_LIB_ROOT});@env{keys%deactivate_env}=values%deactivate_env}my$base="$PERLBREW_HOME/libs/${perl_name}\@${lib_name}";if (-d $base){delete$ENV{PERL_LOCAL_LIB_ROOT};@ENV{keys%env}=values%env;my%lib_env=local::lib->build_environment_vars_for($base,0,1);$env{PERLBREW_PATH}=catdir($base,"bin").":" .$env{PERLBREW_PATH};$env{PERLBREW_MANPATH}=catdir($base,"man").":" .$env{PERLBREW_MANPATH};$env{PERLBREW_LIB}=$lib_name;$env{PERL_MM_OPT}=$lib_env{PERL_MM_OPT};$env{PERL_MB_OPT}=$lib_env{PERL_MB_OPT};$env{PERL5LIB}=$lib_env{PERL5LIB};$env{PERL_LOCAL_LIB_ROOT}=$lib_env{PERL_LOCAL_LIB_ROOT}}}else {my$libroot=$self->env("PERL_LOCAL_LIB_ROOT");if ($libroot && $libroot =~ /^$PERLBREW_HOME/){require local::lib;my%deactivate_env=local::lib->build_deact_all_environment_vars_for($libroot);@env{keys%deactivate_env}=values%deactivate_env;$env{PERLBREW_LIB}=undef}}}else {my$libroot=$self->env("PERL_LOCAL_LIB_ROOT");if ($libroot && $libroot =~ /^$PERLBREW_HOME/){require local::lib;my%deactivate_env=local::lib->build_deact_all_environment_vars_for($libroot);@env{keys%deactivate_env}=values%deactivate_env;$env{PERLBREW_LIB}=undef}$env{PERLBREW_PERL}=undef}return%env}sub run_command_list {my$self=shift;for my$i ($self->installed_perls){print$i->{is_current}? '* ': '  ',$i->{name},(index($i->{name},$i->{version})< 0)? " ($i->{version})" : "","\n";for my$lib (@{$i->{libs}}){print$lib->{is_current}? "* " : "  ",$lib->{name},"\n"}}return 0}sub launch_sub_shell {my ($self,$name)=@_;my$shell=$self->env('SHELL');my$shell_opt="";if ($shell =~ /\/zsh$/){$shell_opt="-d -f";if ($^O eq 'darwin'){my$root_dir=$self->root;print <<"WARNINGONMAC"}}elsif ($shell =~ /\/bash$/){$shell_opt="--noprofile --norc"}my%env=($self->perlbrew_env($name),PERLBREW_SKIP_INIT=>1);unless ($ENV{PERLBREW_VERSION}){my$root=$self->root;$env{PATH}=$env{PERLBREW_PATH}.":" .join ":",grep {!/$root/}split ":",$ENV{PATH};$env{MANPATH}=$env{PERLBREW_MANPATH}.":" .join ":",grep {!/$root/}split ":",$ENV{MANPATH}}my$command="env ";while (my ($k,$v)=each(%env)){$command .= "$k=\"$v\" "}$command .= " $shell $shell_opt";print "\nA sub-shell is launched with $name as the activated perl. Run 'exit' to finish it.\n\n";exec($command)}sub run_command_use {my$self=shift;my$perl=shift;if (!$perl){my$current=$self->current_perl;if ($current){print "Currently using $current\n"}else {print "No version in use; defaulting to system\n"}return}$self->launch_sub_shell($perl)}sub run_command_switch {my ($self,$dist,$alias)=@_;unless ($dist){my$current=$self->current_perl;printf "Currently switched %s\n",($current ? "to $current" : 'off');return}die "Cannot use for alias something that starts with 'perl-'\n" if$alias && $alias =~ /^perl-/;die "${dist} is not installed\n" unless -d catdir($self->root,"perls",$dist);if ($self->env("PERLBREW_BASHRC_VERSION")){local$ENV{PERLBREW_PERL}=$dist;my$HOME=$self->env('HOME');my$pb_home=$self->env("PERLBREW_HOME")|| $PERLBREW_HOME;mkpath($pb_home);system("$0 env $dist > " .catfile($pb_home,"init"));print "Switched to $dist.\n\n"}else {$self->launch_sub_shell($dist)}}sub run_command_off {my$self=shift;$self->launch_sub_shell}sub run_command_switch_off {my$self=shift;my$pb_home=$self->env("PERLBREW_HOME")|| $PERLBREW_HOME;mkpath($pb_home);system("env PERLBREW_PERL= $0 env > " .catfile($pb_home,"init"));print "\nperlbrew is switched off. Please exit this shell and start a new one to make it effective.\n";print "To immediately make it effective, run this line in this terminal:\n\n    exec @{[ $self->env('SHELL') ]}\n\n"}sub run_command_mirror {my($self)=@_;print "Fetching mirror list\n";my$raw=http_get("http://search.cpan.org/mirror");unless ($raw){die "\nERROR: Failed to retrieve the mirror list.\n\n"}my$found;my@mirrors;for my$line (split m{\n},$raw){$found=1 if$line =~ m{<select name="mirror">};next if!$found;last if$line =~ m{</select>};if ($line =~ m{<option value="(.+?)">(.+?)</option>}){my$url=$1;my$name=$2;$name =~ s/&#(\d+);/chr $1/seg;$url =~ s/&#(\d+);/chr $1/seg;push@mirrors,{url=>$url,name=>$name }}}require ExtUtils::MakeMaker;my$select;my$max=@mirrors;my$id=0;while (@mirrors){my@page=splice(@mirrors,0,20);my$base=$id;printf "[% 3d] %s\n",++$id,$_->{name}for@page;my$remaining=$max - $id;my$ask="Select a mirror by number or press enter to see the rest " ."($remaining more) [q to quit, m for manual entry]";my$val=ExtUtils::MakeMaker::prompt($ask);if (!length$val){next}elsif ($val eq 'q'){last}elsif ($val eq 'm'){my$url=ExtUtils::MakeMaker::prompt("Enter the URL of your CPAN mirror:");my$name=ExtUtils::MakeMaker::prompt("Enter a Name: [default: My CPAN Mirror]")|| "My CPAN Mirror";$select={name=>$name,url=>$url };last}elsif (not $val =~ /\s*(\d+)\s*/){die "Invalid answer: must be 'q', 'm' or a number\n"}elsif (1 <= $val and $val <= $max){$select=$page[$val - 1 - $base ];last}else {die "Invalid ID: must be between 1 and $max\n"}}die "You didn't select a mirror!\n" if!$select;print "Selected $select->{name} ($select->{url}) as the mirror\n";my$conf=$self->config;$conf->{mirror}=$select;$self->_save_config;return}sub run_command_env {my($self,$perl)=@_;my%env=$self->perlbrew_env($perl);if ($self->env('SHELL')=~ /(ba|k|z|\/)sh$/){while (my ($k,$v)=each(%env)){if (defined$v){$v =~ s/(\\")/\\$1/g;print "export $k=\"$v\"\n"}else {print "unset $k\n"}}}else {while (my ($k,$v)=each(%env)){if (defined$v){$v =~ s/(\\")/\\$1/g;print "setenv $k \"$v\"\n"}else {print "unsetenv $k\n"}}}}sub run_command_symlink_executables {my($self,@perls)=@_;my$root=$self->root;unless (@perls){@perls=map {m{/([^/]+)$}}grep {-d $_ &&!-l $_}<$root/perls/*>}for my$perl (@perls){for my$executable (<$root/perls/$perl/bin/*>){my ($name,$version)=$executable =~ m/bin\/(.+?)(5\.\d.*)?$/;system("ln -fs $executable $root/perls/$perl/bin/$name")if$version}}}sub run_command_install_patchperl {my ($self)=@_;$self->do_install_program_from_url('https://raw.github.com/gugod/patchperl-packing/master/patchperl','patchperl',sub {my ($body)=@_;$body =~ s/\A#!.+?\n/ $self->system_perl_shebang . "\n" /se;return$body})}sub run_command_install_cpanm {my ($self)=@_;$self->do_install_program_from_url('https://github.com/miyagawa/cpanminus/raw/master/cpanm'=>'cpanm')}sub run_command_install_ack {my ($self)=@_;$self->do_install_program_from_url('http://betterthangrep.com/ack-standalone'=>'ack')}sub run_command_self_upgrade {my ($self)=@_;my$TMPDIR=$ENV{TMPDIR}|| "/tmp";my$TMP_PERLBREW=catfile($TMPDIR,"perlbrew");unless(-w $FindBin::Bin){die "Your perlbrew installation appears to be system-wide.  Please upgrade through your package manager.\n"}http_get('http://get.perlbrew.pl',undef,sub {my ($body)=@_;open my$fh,'>',$TMP_PERLBREW or die "Unable to write perlbrew: $!";print$fh $body;close$fh});chmod 0755,$TMP_PERLBREW;my$new_version=qx($TMP_PERLBREW version);chomp$new_version;if($new_version =~ /App::perlbrew\/(\d+\.\d+)$/){$new_version=$1}else {die "Unable to detect version of new perlbrew!\n"}if($new_version <= $VERSION){print "Your perlbrew is up-to-date.\n";return}system$TMP_PERLBREW,"self-install";unlink$TMP_PERLBREW}sub run_command_uninstall {my ($self,$target)=@_;unless($target){$self->run_command_help("uninstall");exit(-1)}my$dir="@{[ $self->root ]}/perls/$target";if (-l $dir){die "\nThe given name `$target` is an alias, not a real installation. Cannot perform uninstall.\nTo delete the alias, run:\n\n    perlbrew alias delete $target\n\n"}unless(-d $dir){die "'$target' is not installed\n"}exec 'rm','-rf',$dir}sub run_command_exec {my$self=shift;my%opts;local (@ARGV)=@{$self->{original_argv}};shift@ARGV;Getopt::Long::GetOptions(\%opts,'with=s',);my@exec_with=map {($_,@{$_->{libs}})}$self->installed_perls;if ($opts{with}){my$d=($opts{with}=~ / /)? qr( +) : qr(,+);my%x=map {$_=>1}grep {$_}map {my ($p,$l)=$self->resolve_installation_name($_);$p .= "\@$l" if$l;$p}split$d,$opts{with};@exec_with=grep {$x{$_->{name}}}@exec_with}if (0==@exec_with){print "No perl installation found.\n" unless$self->{quiet}}for my$i (@exec_with){next if -l $self->root .'/perls/' .$i->{name};my%env=$self->perlbrew_env($i->{name});next if!$env{PERLBREW_PERL};local@ENV{keys%env }=values%env;local$ENV{PATH}=join(':',$env{PERLBREW_PATH},$ENV{PATH});local$ENV{MANPATH}=join(':',$env{PERLBREW_MANPATH},$ENV{MANPATH}||"");print "$i->{name}\n==========\n" unless$self->{quiet};$self->do_system(@ARGV);print "\n\n" unless$self->{quiet}}}sub run_command_clean {my ($self)=@_;my$root=$self->root;my@build_dirs=<$root/build/*>;for my$dir (@build_dirs){print "Remove $dir\n";rmpath($dir)}print "\nDone\n"}sub run_command_alias {my ($self,$cmd,$name,$alias)=@_;if (!$cmd){print <<USAGE;return}unless ($self->is_installed($name)){die "\nABORT: The installation `${name}` does not exist.\n\n"}my$path_name=catfile($self->root,"perls",$name);my$path_alias=catfile($self->root,"perls",$alias)if$alias;if ($alias && -e $path_alias &&!-l $path_alias){die "\nABORT: The installation name `$alias` is not an alias, cannot override.\n\n"}if ($cmd eq 'create'){if ($self->is_installed($alias)&&!$self->{force}){die "\nABORT: The installation `${alias}` already exists. Cannot override.\n\n"}unlink($path_alias)if -e $path_alias;symlink($path_name,$path_alias)}elsif($cmd eq 'delete'){unless (-l $path_name){die "\nABORT: The installation name `$name` is not an alias, cannot remove.\n\n"}unlink($path_name)}elsif($cmd eq 'rename'){unless (-l $path_name){die "\nABORT: The installation name `$name` is not an alias, cannot rename.\n\n"}if (-l $path_alias &&!$self->{force}){die "\nABORT: The alias `$alias` already exists, cannot rename to it.\n\n"}rename($path_name,$path_alias)}else {die "\nERROR: Unrecognized action: `${cmd}`.\n\n"}}sub run_command_display_bashrc {print BASHRC_CONTENT()}sub run_command_display_cshrc {print CSHRC_CONTENT()}sub lib_usage {my$usage=<<'USAGE';return$usage}sub run_command_lib {my ($self,$subcommand,@args)=@_;unless ($subcommand){print lib_usage;return}my$sub="run_command_lib_$subcommand";if ($self->can($sub)){$self->$sub(@args)}else {print "Unknown command: $subcommand\n"}}sub run_command_lib_create {my ($self,$name)=@_;die "ERROR: No lib name\n",lib_usage unless$name;$name =~ s/^/@/ unless$name =~ /@/;my ($perl_name,$lib_name)=$self->resolve_installation_name($name);if (!$perl_name){my ($perl_name,$lib_name)=split('@',$name);die "ERROR: '$perl_name' is not installed yet, '$name' cannot be created.\n"}my$fullname=$perl_name .'@' .$lib_name;my$dir=catdir($PERLBREW_HOME,"libs",$fullname);if (-d $dir){die "$fullname is already there.\n"}mkpath($dir);print "lib '$fullname' is created.\n" unless$self->{quiet};return}sub run_command_lib_delete {my ($self,$name)=@_;die "ERROR: No lib to delete\n",lib_usage unless$name;$name =~ s/^/@/ unless$name =~ /@/;my ($perl_name,$lib_name)=$self->resolve_installation_name($name);if (!$perl_name){}my$fullname=$perl_name .'@' .$lib_name;my$current=$self->current_perl .'@' .($self->env("PERLBREW_LIB")|| "");my$dir=catdir($PERLBREW_HOME,"libs",$fullname);if (-d $dir){if ($fullname eq $current){die "$fullname is currently being used in the current shell, it cannot be deleted.\n"}rmpath($dir);print "lib '$fullname' is deleted.\n" unless$self->{quiet}}else {die "ERROR: '$fullname' does not exist.\n"}return}sub run_command_lib_list {my ($self)=@_;my$current="";if ($self->current_perl && $self->env("PERLBREW_LIB")){$current=$self->current_perl ."@" .$self->env("PERLBREW_LIB")}my$dir=catdir($PERLBREW_HOME,"libs");return unless -d $dir;opendir my$dh,$dir or die "open $dir failed: $!";my@libs=grep {!/^\./ && /\@/}readdir($dh);for (@libs){print$current eq $_ ? "* " : "  ";print "$_\n"}}sub run_command_upgrade_perl {my ($self)=@_;my$PERL_VERSION_RE=qr/(\d+)\.(\d+)\.(\d+)/;my ($current)=grep {$_->{is_current}}$self->installed_perls;unless(defined$current){print "no perlbrew environment is currently in use\n";exit(1)}my ($major,$minor,$release);if($current->{version}=~ /^$PERL_VERSION_RE$/){($major,$minor,$release)=($1,$2,$3)}else {print "unable to parse version '$current->{version}'\n";exit(1)}my@available=grep {/^perl-$major\.$minor/}$self->available_perls;my$latest_available_perl=$release;for my$perl (@available){if($perl =~ /^perl-$PERL_VERSION_RE$/){my$this_release=$3;if($this_release > $latest_available_perl){$latest_available_perl=$this_release}}}if($latest_available_perl==$release){print "This perlbrew environment ($current->{name}) is already up-to-date.\n";exit(0)}my$dist_version="$major.$minor.$latest_available_perl";my$dist="perl-$dist_version";print "Upgrading $current->{name} to $dist_version\n";local$self->{as}=$current->{name};local$self->{dist_name}=$dist;$self->do_install_release($dist)}sub run_command_list_modules {my ($self)=@_;$self->{quiet}=1;$self->{original_argv}=["exec","--with",$self->current_perl,'perl','-MExtUtils::Installed','-le','print for ExtUtils::Installed->new(skip_cwd => 1)->modules' ];$self->run_command_exec()}sub resolve_installation_name {my ($self,$name)=@_;die "App::perlbrew->resolve_installation_name requires one argument." unless$name;my ($perl_name,$lib_name)=split('@',$name);$perl_name=$name unless$lib_name;$perl_name ||=$self->current_perl;if (!$self->is_installed($perl_name)){if ($self->is_installed("perl-${perl_name}")){$perl_name="perl-${perl_name}"}else {return undef}}return wantarray ? ($perl_name,$lib_name): $perl_name}sub run_command_info {my ($self)=@_;local $\="\n";if ($self->current_perl){print "activated: " .$self->current_perl .($self->current_lib && "@".$self->current_lib)}else {print "Using system perl."}print "perlbrew version: " .$self->VERSION;print "\nENV:";for(map{"PERLBREW_$_"}qw(ROOT HOME PATH MANPATH)){print "  $_: " .($self->env($_)||"")}}sub config {my($self)=@_;$self->_load_config if!$CONFIG;return$CONFIG}sub config_file {my ($self)=@_;catfile($self->root,'Config.pm')}sub _save_config {my($self)=@_;require Data::Dumper;open my$FH,'>',$self->config_file or die "Unable to open config (@{[ $self->config_file ]}): $!";my$d=Data::Dumper->new([$CONFIG],['App::perlbrew::CONFIG']);print$FH $d->Dump;close$FH}sub _load_config {my($self)=@_;if (!-e $self->config_file){local$CONFIG={}if!$CONFIG;$self->_save_config}open my$FH,'<',$self->config_file or die "Unable to open config (@{[ $self->config_file ]}): $!\n";my$raw=do {local $/;my$rv=<$FH>;$rv};close$FH;my$rv=eval$raw;if ($@){warn "Error loading conf: $@\n";$CONFIG={};return}$CONFIG={}if!$CONFIG;return}sub BASHRC_CONTENT() {return "export PERLBREW_BASHRC_VERSION=$VERSION\n\n" .<<'RC'}sub BASH_COMPLETION_CONTENT() {return <<'COMPLETION'}sub CSH_WRAPPER_CONTENT {return <<'WRAPPER'}sub CSH_REINIT_CONTENT {return <<'REINIT'}sub CSH_SET_PATH_CONTENT {return <<'SETPATH'}sub CSHRC_CONTENT {return "setenv PERLBREW_CSHRC_VERSION $VERSION\n\n" .<<'CSHRC'}1;
  
  perlbrew root ($root_dir) is initialized.
  
  Append the following piece of code to the end of your ~/.${yourshrc} and start a
  new shell, perlbrew should be up and fully functional from there:
  
  $code
  
  Simply run `perlbrew` for usage details.
  
  Happy brewing!
  
  INSTRUCTION
  This could take a while. You can run the following command on another shell to track the status:
  
    tail -f @{[ $self->path_with_tilde($self->{log_file}) ]}
  
  INSTALL
  
  Installing $dist_extracted_dir failed. Read $self->{log_file} to spot any
  issues. You might also want to try upgrading patchperl before trying again:
  
    perlbrew install-patchperl
  
  If some perl tests failed and you want to force install the distribution anyway,
  try:
  
    perlbrew --force install $self->{dist_name}
  
  FAIL
  --------------------------------------------------------------------------------
  WARNING: zsh perlbrew sub-shell is not working on Mac OSX Lion.
  
  It is known that on MacOS Lion, zsh always resets the value of PATH on launching
  a sub-shell. Effectively nullify the changes required by perlbrew sub-shell. You
  may `echo \$PATH` to examine it and if you see perlbrew related paths are in the
  end, instead of in the beginning, you are unfortunate.
  
  You are advised to include the following line to your ~/.zshenv as a better
  way to work with perlbrew:
  
      source $root_dir/etc/bashrc
  
  --------------------------------------------------------------------------------
  WARNINGONMAC
  
  Usage: perlbrew alias [-f] <action> <name> [<alias>]
  
      perlbrew alias create <name> <alias>
      perlbrew alias delete <alias>
      perlbrew alias rename <old_alias> <new_alias>
  
  USAGE
  
  Usage: perlbrew lib <action> <name> [<name> <name> ...]
  
      perlbrew lib list
      perlbrew lib create nobita
      perlbrew lib create perl-5.14.2@nobita
  
      perlbrew use perl-5.14.2@nobita
      perlbrew lib delete perl-5.12.3@nobita shizuka
  
  USAGE
  
  __perlbrew_reinit() {
      if [[ ! -d "$PERLBREW_HOME" ]]; then
          mkdir -p "$PERLBREW_HOME"
      fi
  
      echo '# DO NOT EDIT THIS FILE' > "$PERLBREW_HOME/init"
      command perlbrew env $1 | grep PERLBREW_ >> "$PERLBREW_HOME/init"
      . "$PERLBREW_HOME/init"
      __perlbrew_set_path
  }
  
  __perlbrew_set_path () {
      MANPATH_WITHOUT_PERLBREW=`perl -e 'print join ":", grep { index($_, $ENV{PERLBREW_HOME}) < 0 } grep { index($_, $ENV{PERLBREW_ROOT}) < 0 } split/:/,qx(manpath 2> /dev/null);'`
      if [ -n "$PERLBREW_MANPATH" ]; then
          export MANPATH="$PERLBREW_MANPATH:$MANPATH_WITHOUT_PERLBREW"
      else
          export MANPATH="$MANPATH_WITHOUT_PERLBREW"
      fi
      unset MANPATH_WITHOUT_PERLBREW
  
      PATH_WITHOUT_PERLBREW=`$perlbrew_command display-pristine-path`
      if [ -n "$PERLBREW_PATH" ]; then
          export PATH=${PERLBREW_PATH}:${PATH_WITHOUT_PERLBREW}
      else
          export PATH=${PERLBREW_ROOT}/bin:${PATH_WITHOUT_PERLBREW}
      fi
      unset PATH_WITHOUT_PERLBREW
  
      hash -r
  }
  
  __perlbrew_activate() {
      [[ -n $(alias perl 2>/dev/null) ]] && unalias perl 2>/dev/null
  
      if [[ -n "$PERLBREW_PERL" ]]; then
          if [[ -z "$PERLBREW_LIB" ]]; then
              eval "$($perlbrew_command env $PERLBREW_PERL)"
          else
              eval "$(${perlbrew_command} env $PERLBREW_PERL@$PERLBREW_LIB)"
          fi
      fi
  
      __perlbrew_set_path
  }
  
  __perlbrew_deactivate() {
      eval "$($perlbrew_command env)"
      unset PERLBREW_PERL
      unset PERLBREW_LIB
      __perlbrew_set_path
  }
  
  perlbrew () {
      local exit_status
      local short_option
      export SHELL
  
      if [[ $1 == -* ]]; then
          short_option=$1
          shift
      else
          short_option=""
      fi
  
      case $1 in
          (use)
              if [[ -z "$2" ]] ; then
                  if [[ -z "$PERLBREW_PERL" ]] ; then
                      echo "Currently using system perl"
                  else
                      echo "Currently using $PERLBREW_PERL"
                  fi
              else
                  code="$(command perlbrew env $2);"
                  if [ -z "$code" ]; then
                      exit_status=1
                  else
                      eval $code
                      __perlbrew_set_path
                  fi
              fi
              ;;
  
          (switch)
                if [[ -z "$2" ]] ; then
                    command perlbrew switch
                else
                    perlbrew use $2 && __perlbrew_reinit $2
                fi
                ;;
  
          (off)
              __perlbrew_deactivate
              echo "perlbrew is turned off."
              ;;
  
          (switch-off)
              __perlbrew_deactivate
              __perlbrew_reinit
              echo "perlbrew is switched off."
              ;;
  
          (*)
              command perlbrew $short_option "$@"
              exit_status=$?
              ;;
      esac
      hash -r
      return ${exit_status:-0}
  }
  
  [[ -z "$PERLBREW_ROOT" ]] && export PERLBREW_ROOT="$HOME/perl5/perlbrew"
  [[ -z "$PERLBREW_HOME" ]] && export PERLBREW_HOME="$HOME/.perlbrew"
  
  if [[ ! -n "$PERLBREW_SKIP_INIT" ]]; then
      if [[ -f "$PERLBREW_HOME/init" ]]; then
          . "$PERLBREW_HOME/init"
      fi
  fi
  
  perlbrew_bin_path="${PERLBREW_ROOT}/bin"
  if [[ -f $perlbrew_bin_path/perlbrew ]]; then
      perlbrew_command="$perlbrew_bin_path/perlbrew"
  else
      perlbrew_command="command perlbrew"
  fi
  unset perlbrew_bin_path
  
  __perlbrew_activate
  
  RC
  if [[ -n ${ZSH_VERSION-} ]]; then
      autoload -U +X bashcompinit && bashcompinit
  fi
  
  export PERLBREW="command perlbrew"
  _perlbrew_compgen()
  {
      COMPREPLY=( $($PERLBREW compgen $COMP_CWORD ${COMP_WORDS[*]}) )
  }
  complete -F _perlbrew_compgen perlbrew
  COMPLETION
  set perlbrew_exit_status=0
  
  if ( $1 =~ -* ) then
      set perlbrew_short_option=$1
      shift
  else
      set perlbrew_short_option=""
  endif
  
  switch ( $1 )
      case use:
          if ( $%2 == 0 ) then
              if ( $?PERLBREW_PERL == 0 ) then
                  echo "Currently using system perl"
              else
                  if ( $%PERLBREW_PERL == 0 ) then
                      echo "Currently using system perl"
                  else
                      echo "Currently using $PERLBREW_PERL"
                  endif
              endif
          else
              set perlbrew_line_count=0
              foreach perlbrew_line ( "`\perlbrew env $2`" )
                  eval $perlbrew_line
                  @ perlbrew_line_count++
              end
              if ( $perlbrew_line_count == 0 ) then
                  set perlbrew_exit_status=1
              else
                  source "$PERLBREW_ROOT/etc/csh_set_path"
              endif
          endif
          breaksw
  
      case switch:
          if ( $%2 == 0 ) then
              \perlbrew switch
          else
              perlbrew use $2 && source $PERLBREW_ROOT/etc/csh_reinit $2
          endif
          breaksw
  
      case off:
          unsetenv PERLBREW_PERL
          foreach perlbrew_line ( "`\perlbrew env`" )
              eval $perlbrew_line
          end
          source $PERLBREW_ROOT/etc/csh_set_path
          echo "perlbrew is turned off."
          breaksw
  
      case switch-off:
          unsetenv PERLBREW_PERL
          source $PERLBREW_ROOT/etc/csh_reinit ''
          echo "perlbrew is switched off."
          breaksw
  
      default:
          \perlbrew $perlbrew_short_option $argv
          set perlbrew_exit_status=$?
          breaksw
  endsw
  rehash
  exit $perlbrew_exit_status
  WRAPPER
  if ( ! -d "$PERLBREW_HOME" ) then
      mkdir -p "$PERLBREW_HOME"
  endif
  
  echo '# DO NOT EDIT THIS FILE' >! "$PERLBREW_HOME/init"
  \perlbrew env $1 >> "$PERLBREW_HOME/init"
  source "$PERLBREW_HOME/init"
  source "$PERLBREW_ROOT/etc/csh_set_path"
  REINIT
  unalias perl
  
  if ( $?PERLBREW_PATH == 0 ) then
      setenv PERLBREW_PATH "$PERLBREW_ROOT/bin"
  endif
  
  setenv PATH_WITHOUT_PERLBREW `perl -e 'print join ":", grep { index($_, $ENV{PERLBREW_ROOT}) } split/:/,$ENV{PATH};'`
  setenv PATH ${PERLBREW_PATH}:${PATH_WITHOUT_PERLBREW}
  
  setenv MANPATH_WITHOUT_PERLBREW `perl -e 'print join ":", grep { index($_, $ENV{PERLBREW_ROOT}) } split/:/,qx(manpath 2> /dev/null);'`
  if ( $?PERLBREW_MANPATH == 1 ) then
      setenv MANPATH ${PERLBREW_MANPATH}:${MANPATH_WITHOUT_PERLBREW}
  else
      setenv MANPATH ${MANPATH_WITHOUT_PERLBREW}
  endif
  SETPATH
  
  if ( $?PERLBREW_HOME == 0 ) then
      setenv PERLBREW_HOME "$HOME/.perlbrew"
  endif
  
  if ( $?PERLBREW_ROOT == 0 ) then
      setenv PERLBREW_ROOT "$HOME/perl5/perlbrew"
  endif
  
  if ( $?PERLBREW_SKIP_INIT == 0 ) then
      if ( -f "$PERLBREW_HOME/init" ) then
          source "$PERLBREW_HOME/init"
      endif
  endif
  
  if ( $?PERLBREW_PATH == 0 ) then
      setenv PERLBREW_PATH "$PERLBREW_ROOT/bin"
  endif
  
  source "$PERLBREW_ROOT/etc/csh_set_path"
  alias perlbrew 'source $PERLBREW_ROOT/etc/csh_wrapper'
  CSHRC
APP_PERLBREW

$fatpacked{"CPAN/Perl/Releases.pm"} = <<'CPAN_PERL_RELEASES';
  package CPAN::Perl::Releases;{$CPAN::Perl::Releases::VERSION='0.70'}use strict;use warnings;use vars qw[@ISA @EXPORT_OK];use Exporter;@ISA=qw(Exporter);@EXPORT_OK=qw(perl_tarballs);our$data={"5.003_07"=>{"tar.gz"=>"A/AN/ANDYD/perl5.003_07.tar.gz",},"5.004"=>{"tar.gz"=>"C/CH/CHIPS/perl5.004.tar.gz",},"5.004_01"=>{"tar.gz"=>"T/TI/TIMB/perl5.004_01.tar.gz",},"5.004_02"=>{"tar.gz"=>"T/TI/TIMB/perl5.004_02.tar.gz",},"5.004_03"=>{"tar.gz"=>"T/TI/TIMB/perl5.004_03.tar.gz",},"5.004_04"=>{"tar.gz"=>"T/TI/TIMB/perl5.004_04.tar.gz",},"5.004_05"=>{"tar.gz"=>"C/CH/CHIPS/perl5.004_05.tar.gz",},"5.005"=>{"tar.gz"=>"G/GS/GSAR/perl5.005.tar.gz",},"5.005_01"=>{"tar.gz"=>"G/GS/GSAR/perl5.005_01.tar.gz",},"5.005_02"=>{"tar.gz"=>"G/GS/GSAR/perl5.005_02.tar.gz",},"5.005_03"=>{"tar.gz"=>"G/GB/GBARR/perl5.005_03.tar.gz",},"5.005_04"=>{"tar.gz"=>"L/LB/LBROCARD/perl5.005_04.tar.gz",},"5.10.0"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.10.0.tar.gz",},"5.10.0-RC1"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.10.0-RC1.tar.gz",},"5.10.0-RC2"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.10.0-RC2.tar.gz",},"5.10.1"=>{"tar.bz2"=>"D/DA/DAPM/perl-5.10.1.tar.bz2","tar.gz"=>"D/DA/DAPM/perl-5.10.1.tar.gz",},"5.11.0"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.11.0.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.11.0.tar.gz",},"5.11.1"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.11.1.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.11.1.tar.gz",},"5.11.2"=>{"tar.bz2"=>"L/LB/LBROCARD/perl-5.11.2.tar.bz2","tar.gz"=>"L/LB/LBROCARD/perl-5.11.2.tar.gz",},"5.11.3"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.11.3.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.11.3.tar.gz",},"5.11.4"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.11.4.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.11.4.tar.gz",},"5.11.5"=>{"tar.bz2"=>"S/SH/SHAY/perl-5.11.5.tar.bz2","tar.gz"=>"S/SH/SHAY/perl-5.11.5.tar.gz",},"5.12.0"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.12.0.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.12.0.tar.gz",},"5.12.1"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.12.1.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.12.1.tar.gz",},"5.12.1-RC1"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.12.1-RC1.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.12.1-RC1.tar.gz",},"5.12.1-RC2"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.12.1-RC2.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.12.1-RC2.tar.gz",},"5.12.2"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.12.2.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.12.2.tar.gz",},"5.12.2-RC1"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.12.2-RC1.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.12.2-RC1.tar.gz",},"5.12.3"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.12.3.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.12.3.tar.gz",},"5.12.4-RC1"=>{"tar.bz2"=>"L/LB/LBROCARD/perl-5.12.4-RC1.tar.bz2","tar.gz"=>"L/LB/LBROCARD/perl-5.12.4-RC1.tar.gz",},"5.12.4-RC2"=>{"tar.bz2"=>"L/LB/LBROCARD/perl-5.12.4-RC2.tar.bz2","tar.gz"=>"L/LB/LBROCARD/perl-5.12.4-RC2.tar.gz",},"5.12.4"=>{"tar.bz2"=>"L/LB/LBROCARD/perl-5.12.4.tar.bz2","tar.gz"=>"L/LB/LBROCARD/perl-5.12.4.tar.gz",},"5.13.0"=>{"tar.bz2"=>"L/LB/LBROCARD/perl-5.13.0.tar.bz2","tar.gz"=>"L/LB/LBROCARD/perl-5.13.0.tar.gz",},"5.13.1"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.13.1.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.13.1.tar.gz",},"5.13.10"=>{"tar.bz2"=>"A/AV/AVAR/perl-5.13.10.tar.bz2","tar.gz"=>"A/AV/AVAR/perl-5.13.10.tar.gz",},"5.13.11"=>{"tar.bz2"=>"F/FL/FLORA/perl-5.13.11.tar.bz2","tar.gz"=>"F/FL/FLORA/perl-5.13.11.tar.gz",},"5.13.2"=>{"tar.bz2"=>"M/MS/MSTROUT/perl-5.13.2.tar.bz2","tar.gz"=>"M/MS/MSTROUT/perl-5.13.2.tar.gz",},"5.13.3"=>{"tar.bz2"=>"D/DA/DAGOLDEN/perl-5.13.3.tar.bz2","tar.gz"=>"D/DA/DAGOLDEN/perl-5.13.3.tar.gz",},"5.13.4"=>{"tar.bz2"=>"F/FL/FLORA/perl-5.13.4.tar.bz2","tar.gz"=>"F/FL/FLORA/perl-5.13.4.tar.gz",},"5.13.5"=>{"tar.bz2"=>"S/SH/SHAY/perl-5.13.5.tar.bz2","tar.gz"=>"S/SH/SHAY/perl-5.13.5.tar.gz",},"5.13.6"=>{"tar.bz2"=>"M/MI/MIYAGAWA/perl-5.13.6.tar.bz2","tar.gz"=>"M/MI/MIYAGAWA/perl-5.13.6.tar.gz",},"5.13.7"=>{"tar.bz2"=>"B/BI/BINGOS/perl-5.13.7.tar.bz2","tar.gz"=>"B/BI/BINGOS/perl-5.13.7.tar.gz",},"5.13.8"=>{"tar.bz2"=>"Z/ZE/ZEFRAM/perl-5.13.8.tar.bz2","tar.gz"=>"Z/ZE/ZEFRAM/perl-5.13.8.tar.gz",},"5.13.9"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.13.9.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.13.9.tar.gz",},"5.14.0"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.14.0.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.14.0.tar.gz",},"5.14.0-RC1"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.14.0-RC1.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.14.0-RC1.tar.gz",},"5.14.0-RC2"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.14.0-RC2.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.14.0-RC2.tar.gz",},"5.14.0-RC3"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.14.0-RC3.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.14.0-RC3.tar.gz",},"5.14.1-RC1"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.14.1-RC1.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.14.1-RC1.tar.gz",},"5.14.1"=>{"tar.bz2"=>"J/JE/JESSE/perl-5.14.1.tar.bz2","tar.gz"=>"J/JE/JESSE/perl-5.14.1.tar.gz",},"5.14.2-RC1"=>{"tar.bz2"=>"F/FL/FLORA/perl-5.14.2-RC1.tar.bz2","tar.gz"=>"F/FL/FLORA/perl-5.14.2-RC1.tar.gz",},"5.14.2"=>{"tar.bz2"=>"F/FL/FLORA/perl-5.14.2.tar.bz2","tar.gz"=>"F/FL/FLORA/perl-5.14.2.tar.gz",},"5.15.0"=>{"tar.bz2"=>"D/DA/DAGOLDEN/perl-5.15.0.tar.bz2","tar.gz"=>"D/DA/DAGOLDEN/perl-5.15.0.tar.gz",},"5.15.1"=>{"tar.bz2"=>"Z/ZE/ZEFRAM/perl-5.15.1.tar.bz2","tar.gz"=>"Z/ZE/ZEFRAM/perl-5.15.1.tar.gz",},"5.15.2"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.15.2.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.15.2.tar.gz",},"5.15.3"=>{"tar.bz2"=>"S/ST/STEVAN/perl-5.15.3.tar.bz2","tar.gz"=>"S/ST/STEVAN/perl-5.15.3.tar.gz",},"5.15.4"=>{"tar.bz2"=>"F/FL/FLORA/perl-5.15.4.tar.bz2","tar.gz"=>"F/FL/FLORA/perl-5.15.4.tar.gz",},"5.15.5"=>{"tar.bz2"=>"S/SH/SHAY/perl-5.15.5.tar.bz2","tar.gz"=>"S/SH/SHAY/perl-5.15.5.tar.gz",},"5.15.6"=>{"tar.bz2"=>"D/DR/DROLSKY/perl-5.15.6.tar.bz2","tar.gz"=>"D/DR/DROLSKY/perl-5.15.6.tar.gz",},"5.15.7"=>{"tar.bz2"=>"B/BI/BINGOS/perl-5.15.7.tar.bz2","tar.gz"=>"B/BI/BINGOS/perl-5.15.7.tar.gz",},"5.15.8"=>{"tar.bz2"=>"C/CO/CORION/perl-5.15.8.tar.bz2","tar.gz"=>"C/CO/CORION/perl-5.15.8.tar.gz",},"5.15.9"=>{"tar.bz2"=>"A/AB/ABIGAIL/perl-5.15.9.tar.bz2","tar.gz"=>"A/AB/ABIGAIL/perl-5.15.9.tar.gz",},"5.16.0-RC0"=>{"tar.gz"=>"R/RJ/RJBS/perl-5.16.0-RC0.tar.gz",},"5.16.0-RC1"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.16.0-RC1.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.16.0-RC1.tar.gz",},"5.16.0-RC2"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.16.0-RC2.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.16.0-RC2.tar.gz",},"5.16.0"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.16.0.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.16.0.tar.gz",},"5.16.1-RC1"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.16.1-RC1.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.16.1-RC1.tar.gz",},"5.16.1"=>{"tar.bz2"=>"R/RJ/RJBS/perl-5.16.1.tar.bz2","tar.gz"=>"R/RJ/RJBS/perl-5.16.1.tar.gz",},"5.17.0"=>{"tar.bz2"=>"Z/ZE/ZEFRAM/perl-5.17.0.tar.bz2","tar.gz"=>"Z/ZE/ZEFRAM/perl-5.17.0.tar.gz",},"5.17.1"=>{"tar.bz2"=>"D/DO/DOY/perl-5.17.1.tar.bz2","tar.gz"=>"D/DO/DOY/perl-5.17.1.tar.gz",},"5.17.2"=>{"tar.bz2"=>"T/TO/TONYC/perl-5.17.2.tar.bz2","tar.gz"=>"T/TO/TONYC/perl-5.17.2.tar.gz",},"5.17.3"=>{"tar.bz2"=>"S/SH/SHAY/perl-5.17.3.tar.bz2","tar.gz"=>"S/SH/SHAY/perl-5.17.3.tar.gz",},"5.17.4"=>{"tar.bz2"=>"F/FL/FLORA/perl-5.17.4.tar.bz2","tar.gz"=>"F/FL/FLORA/perl-5.17.4.tar.gz",},"5.6.0"=>{"tar.gz"=>"G/GS/GSAR/perl-5.6.0.tar.gz",},"5.6.1"=>{"tar.gz"=>"G/GS/GSAR/perl-5.6.1.tar.gz",},"5.6.1-TRIAL1"=>{"tar.gz"=>"G/GS/GSAR/perl-5.6.1-TRIAL1.tar.gz",},"5.6.1-TRIAL2"=>{"tar.gz"=>"G/GS/GSAR/perl-5.6.1-TRIAL2.tar.gz",},"5.6.1-TRIAL3"=>{"tar.gz"=>"G/GS/GSAR/perl-5.6.1-TRIAL3.tar.gz",},"5.6.2"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.6.2.tar.gz",},"5.7.0"=>{"tar.gz"=>"J/JH/JHI/perl-5.7.0.tar.gz",},"5.7.1"=>{"tar.gz"=>"J/JH/JHI/perl-5.7.1.tar.gz",},"5.7.2"=>{"tar.gz"=>"J/JH/JHI/perl-5.7.2.tar.gz",},"5.7.3"=>{"tar.gz"=>"J/JH/JHI/perl-5.7.3.tar.gz",},"5.8.0"=>{"tar.gz"=>"J/JH/JHI/perl-5.8.0.tar.gz",},"5.8.1"=>{"tar.gz"=>"J/JH/JHI/perl-5.8.1.tar.gz",},"5.8.2"=>{"tar.bz2"=>"N/NW/NWCLARK/perl-5.8.2.tar.bz2","tar.gz"=>"N/NW/NWCLARK/perl-5.8.2.tar.gz",},"5.8.3"=>{"tar.bz2"=>"N/NW/NWCLARK/perl-5.8.3.tar.bz2","tar.gz"=>"N/NW/NWCLARK/perl-5.8.3.tar.gz",},"5.8.4"=>{"tar.bz2"=>"N/NW/NWCLARK/perl-5.8.4.tar.bz2","tar.gz"=>"N/NW/NWCLARK/perl-5.8.4.tar.gz",},"5.8.5"=>{"tar.bz2"=>"N/NW/NWCLARK/perl-5.8.5.tar.bz2","tar.gz"=>"N/NW/NWCLARK/perl-5.8.5.tar.gz",},"5.8.6"=>{"tar.bz2"=>"N/NW/NWCLARK/perl-5.8.6.tar.bz2","tar.gz"=>"N/NW/NWCLARK/perl-5.8.6.tar.gz",},"5.8.7"=>{"tar.bz2"=>"N/NW/NWCLARK/perl-5.8.7.tar.bz2","tar.gz"=>"N/NW/NWCLARK/perl-5.8.7.tar.gz",},"5.8.8"=>{"tar.bz2"=>"N/NW/NWCLARK/perl-5.8.8.tar.bz2","tar.gz"=>"N/NW/NWCLARK/perl-5.8.8.tar.gz",},"5.8.9"=>{"tar.bz2"=>"N/NW/NWCLARK/perl-5.8.9.tar.bz2","tar.gz"=>"N/NW/NWCLARK/perl-5.8.9.tar.gz",},"5.9.0"=>{"tar.bz2"=>"H/HV/HVDS/perl-5.9.0.tar.bz2","tar.gz"=>"H/HV/HVDS/perl-5.9.0.tar.gz",},"5.9.1"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.9.1.tar.gz",},"5.9.2"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.9.2.tar.gz",},"5.9.3"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.9.3.tar.gz",},"5.9.4"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.9.4.tar.gz",},"5.9.5"=>{"tar.gz"=>"R/RG/RGARCIA/perl-5.9.5.tar.gz",},};sub perl_tarballs {my$vers=shift;$vers=shift if eval {$vers->isa(__PACKAGE__)};return unless exists$data->{$vers };return {%{$data->{$vers }}}}q|Acme::Why::Did::I::Not::Read::The::Fecking::Memo|;
CPAN_PERL_RELEASES

$fatpacked{"Capture/Tiny.pm"} = <<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.20';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-e','$SIG{HUP}=sub{exit}; ' .'if( my $fn=shift ){ open my $fh, qq{>$fn}; print {$fh} $$; close $fh;} ' .'my $buf; while (sysread(STDIN, $buf, 2048)) { ' .'syswrite(STDOUT, $buf); syswrite(STDERR, $buf)}');sub _relayer {my ($fh,$layers)=@_;my%seen=(unix=>1,perlio=>1);my@unique=grep {!$seen{$_}++}@$layers;binmode($fh,join(":",":raw",@unique))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar tmpnam();if ($IS_WIN32){local $@;eval "use Win32API::File qw/CloseHandle GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which})}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){CloseHandle(GetOsFHandle($_))for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||=File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,@result);{local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;local $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if (defined wantarray or ($do_tee && keys%localize)){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
CAPTURE_TINY

$fatpacked{"File/Path/Tiny.pm"} = <<'FILE_PATH_TINY';
  package File::Path::Tiny;$File::Path::Tiny::VERSION=0.5;sub mk {my ($path,$mask)=@_;return 2 if -d $path;if (-e $path){$!=20;return}$mask ||='0777';$mask=oct($mask)if substr($mask,0,1)eq '0';require File::Spec;my ($progressive,@parts)=File::Spec->splitdir($path);if (!defined$progressive || $progressive eq ''){$progressive=File::Spec->catdir($progressive,shift(@parts))}if (!-d $progressive){mkdir($progressive,$mask)or return}for my$part (@parts){$progressive=File::Spec->catdir($progressive,$part);if (!-d $progressive){mkdir($progressive,$mask)or return}}return 1 if -d $path;return}sub rm {my ($path)=@_;if (-e $path &&!-d $path){$!=20;return}return 2 if!-d $path;empty_dir($path)or return;rmdir($path)or return;return 1}sub empty_dir {my ($path)=@_;if (-e $path &&!-d $path){$!=20;return}opendir(DIR,$path)or return;my@contents=grep {$_ ne '.' && $_ ne '..'}readdir(DIR);closedir DIR;require File::Spec if@contents;for my$thing (@contents){my$long=File::Spec->catdir($path,$thing);if (!-l $long && -d $long){rm($long)or return}else {unlink$long or return}}return 1}1;
FILE_PATH_TINY

$fatpacked{"lib/core/only.pm"} = <<'LIB_CORE_ONLY';
  package lib::core::only;use strict;use warnings FATAL=>'all';use Config;sub import {@INC=@Config{qw(privlibexp archlibexp)};return}1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = <<'LOCAL_LIB';
  use strict;use warnings;package local::lib;use 5.008001;use File::Spec ();use File::Path ();use Carp ();use Config;our$VERSION='1.008004';our@KNOWN_FLAGS=qw(--self-contained --deactivate --deactivate-all);sub DEACTIVATE_ONE () {1}sub DEACTIVATE_ALL () {2}sub INTERPOLATE_ENV () {1}sub LITERAL_ENV () {0}sub import {my ($class,@args)=@_;my$perl5lib=$ENV{PERL5LIB}|| '';my%arg_store;for my$arg (@args){if ($arg =~ //){die <<'DEATH'}elsif(grep {$arg eq $_}@KNOWN_FLAGS){(my$flag=$arg)=~ s/--//;$arg_store{$flag}=1}elsif($arg =~ /^--/){die "Unknown import argument: $arg"}else {$arg_store{path}=$arg}}if($arg_store{'self-contained'}){die "FATAL: The local::lib --self-contained flag has never worked reliably and the original author, Mark Stosberg, was unable or unwilling to maintain it. As such, this flag has been removed from the local::lib codebase in order to prevent misunderstandings and potentially broken builds. The local::lib authors recommend that you look at the lib::core::only module shipped with this distribution in order to create a more robust environment that is equivalent to what --self-contained provided (although quite possibly not what you originally thought it provided due to the poor quality of the documentation, for which we apologise).\n"}my$deactivating=0;if ($arg_store{deactivate}){$deactivating=DEACTIVATE_ONE}if ($arg_store{'deactivate-all'}){$deactivating=DEACTIVATE_ALL}$arg_store{path}=$class->resolve_path($arg_store{path});$class->setup_local_lib_for($arg_store{path},$deactivating);for (@INC){next if ref;m/(.*)/ and $_=$1}}sub pipeline;sub pipeline {my@methods=@_;my$last=pop(@methods);if (@methods){\sub {my ($obj,@args)=@_;$obj->${pipeline@methods}($obj->$last(@args))}}else {\sub {shift->$last(@_)}}}sub _uniq {my%seen;grep {!$seen{$_}++}@_}sub resolve_path {my ($class,$path)=@_;$class->${pipeline qw(resolve_relative_path resolve_home_path resolve_empty_path)}($path)}sub resolve_empty_path {my ($class,$path)=@_;if (defined$path){$path}else {'~/perl5'}}sub resolve_home_path {my ($class,$path)=@_;return$path unless ($path =~ /^~/);my ($user)=($path =~ /^~([^\/]+)/);my$tried_file_homedir;my$homedir=do {if (eval {require File::HomeDir}&& $File::HomeDir::VERSION >= 0.65){$tried_file_homedir=1;if (defined$user){File::HomeDir->users_home($user)}else {File::HomeDir->my_home}}else {if (defined$user){(getpwnam$user)[7]}else {if (defined$ENV{HOME}){$ENV{HOME}}else {(getpwuid $<)[7]}}}};unless (defined$homedir){Carp::croak("Couldn't resolve homedir for " .(defined$user ? $user : 'current user').($tried_file_homedir ? '' : ' - consider installing File::HomeDir'))}$path =~ s/^~[^\/]*/$homedir/;$path}sub resolve_relative_path {my ($class,$path)=@_;$path=File::Spec->rel2abs($path)}sub setup_local_lib_for {my ($class,$path,$deactivating)=@_;my$interpolate=LITERAL_ENV;my@active_lls=$class->active_paths;$path=$class->ensure_dir_structure_for($path);if (!$deactivating){if (@active_lls && $active_lls[-1]eq $path){exit 0 if $0 eq '-';return}elsif (grep {$_ eq $path}@active_lls){$class->setup_env_hash_for($path,DEACTIVATE_ONE);$interpolate=INTERPOLATE_ENV}}if ($0 eq '-'){$class->print_environment_vars_for($path,$deactivating,$interpolate);exit 0}else {$class->setup_env_hash_for($path,$deactivating);@INC=_uniq(split($Config{path_sep},$ENV{PERL5LIB}),@INC)}}sub install_base_bin_path {my ($class,$path)=@_;File::Spec->catdir($path,'bin')}sub install_base_perl_path {my ($class,$path)=@_;File::Spec->catdir($path,'lib','perl5')}sub install_base_arch_path {my ($class,$path)=@_;File::Spec->catdir($class->install_base_perl_path($path),$Config{archname})}sub ensure_dir_structure_for {my ($class,$path)=@_;unless (-d $path){warn "Attempting to create directory ${path}\n"}File::Path::mkpath($path);$path=Win32::GetShortPathName($path)if $^O eq 'MSWin32';return$path}sub guess_shelltype {my$shellbin='sh';if(defined$ENV{'SHELL'}){my@shell_bin_path_parts=File::Spec->splitpath($ENV{'SHELL'});$shellbin=$shell_bin_path_parts[-1]}my$shelltype=do {local $_=$shellbin;if(/csh/){'csh'}else {'bourne'}};if (defined$ENV{'COMSPEC'}&& $^O ne 'cygwin'){my@shell_bin_path_parts=File::Spec->splitpath($ENV{'COMSPEC'});$shellbin=$shell_bin_path_parts[-1];$shelltype=do {local $_=$shellbin;if(/command\.com/){'win32'}elsif(/cmd\.exe/){'win32'}elsif(/4nt\.exe/){'win32'}else {$shelltype}}}return$shelltype}sub print_environment_vars_for {my ($class,$path,$deactivating,$interpolate)=@_;print$class->environment_vars_string_for($path,$deactivating,$interpolate)}sub environment_vars_string_for {my ($class,$path,$deactivating,$interpolate)=@_;my@envs=$class->build_environment_vars_for($path,$deactivating,$interpolate);my$out='';my$shelltype=$class->guess_shelltype;while (@envs){my ($name,$value)=(shift(@envs),shift(@envs));$value =~ s/(\\")/\\$1/g if defined$value;$out .= $class->${\"build_${shelltype}_env_declaration"}($name,$value)}return$out}sub build_bourne_env_declaration {my$class=shift;my($name,$value)=@_;return defined($value)? qq{export ${name}="${value}";\n} : qq{unset ${name};\n}}sub build_csh_env_declaration {my$class=shift;my($name,$value)=@_;return defined($value)? qq{setenv ${name} "${value}"\n} : qq{unsetenv ${name}\n}}sub build_win32_env_declaration {my$class=shift;my($name,$value)=@_;return defined($value)? qq{set ${name}=${value}\n} : qq{set ${name}=\n}}sub setup_env_hash_for {my ($class,$path,$deactivating)=@_;my%envs=$class->build_environment_vars_for($path,$deactivating,INTERPOLATE_ENV);@ENV{keys%envs}=values%envs}sub build_environment_vars_for {my ($class,$path,$deactivating,$interpolate)=@_;if ($deactivating==DEACTIVATE_ONE){return$class->build_deactivate_environment_vars_for($path,$interpolate)}elsif ($deactivating==DEACTIVATE_ALL){return$class->build_deact_all_environment_vars_for($path,$interpolate)}else {return$class->build_activate_environment_vars_for($path,$interpolate)}}sub build_activate_environment_vars_for {my ($class,$path,$interpolate)=@_;return (PERL_LOCAL_LIB_ROOT=>join($Config{path_sep},(($ENV{PERL_LOCAL_LIB_ROOT}||())? ($interpolate==INTERPOLATE_ENV ? ($ENV{PERL_LOCAL_LIB_ROOT}||()): (($^O ne 'MSWin32')? '$PERL_LOCAL_LIB_ROOT' : '%PERL_LOCAL_LIB_ROOT%')): ()),$path),PERL_MB_OPT=>"--install_base ${path}",PERL_MM_OPT=>"INSTALL_BASE=${path}",PERL5LIB=>join($Config{path_sep},$class->install_base_arch_path($path),$class->install_base_perl_path($path),(($ENV{PERL5LIB}||())? ($interpolate==INTERPOLATE_ENV ? ($ENV{PERL5LIB}): (($^O ne 'MSWin32')? '$PERL5LIB' : '%PERL5LIB%')): ())),PATH=>join($Config{path_sep},$class->install_base_bin_path($path),($interpolate==INTERPOLATE_ENV ? ($ENV{PATH}||()): (($^O ne 'MSWin32')? '$PATH' : '%PATH%'))),)}sub active_paths {my ($class)=@_;return ()unless defined$ENV{PERL_LOCAL_LIB_ROOT};return split /\Q$Config{path_sep}/,$ENV{PERL_LOCAL_LIB_ROOT}}sub build_deactivate_environment_vars_for {my ($class,$path,$interpolate)=@_;my@active_lls=$class->active_paths;if (!grep {$_ eq $path}@active_lls){warn "Tried to deactivate inactive local::lib '$path'\n";return ()}my@new_ll_root=grep {$_ ne $path}@active_lls;my@new_perl5lib=grep {$_ ne $class->install_base_arch_path($path)&& $_ ne $class->install_base_perl_path($path)}split /\Q$Config{path_sep}/,$ENV{PERL5LIB};my%env=(PERL_LOCAL_LIB_ROOT=>(@new_ll_root ? join($Config{path_sep},@new_ll_root): undef),PERL5LIB=>(@new_perl5lib ? join($Config{path_sep},@new_perl5lib): undef),PATH=>join($Config{path_sep},grep {$_ ne $class->install_base_bin_path($path)}split /\Q$Config{path_sep}/,$ENV{PATH}),);if ($active_lls[-1]eq $path){if (@active_lls > 1){my$new_top=$active_lls[-2];%env=(%env,PERL_MB_OPT=>"--install_base ${new_top}",PERL_MM_OPT=>"INSTALL_BASE=${new_top}",)}else {%env=(%env,PERL_MB_OPT=>undef,PERL_MM_OPT=>undef,)}}return%env}sub build_deact_all_environment_vars_for {my ($class,$path,$interpolate)=@_;my@active_lls=$class->active_paths;my@new_perl5lib=split /\Q$Config{path_sep}/,$ENV{PERL5LIB};my@new_path=split /\Q$Config{path_sep}/,$ENV{PATH};for my$path (@active_lls){@new_perl5lib=grep {$_ ne $class->install_base_arch_path($path)&& $_ ne $class->install_base_perl_path($path)}@new_perl5lib;@new_path=grep {$_ ne $class->install_base_bin_path($path)}@new_path}my%env=(PERL_LOCAL_LIB_ROOT=>undef,PERL_MM_OPT=>undef,PERL_MB_OPT=>undef,PERL5LIB=>(@new_perl5lib ? join($Config{path_sep},@new_perl5lib): undef),PATH=>join($Config{path_sep},@new_path),);return%env}1;
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
LOCAL_LIB

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/perl
use strict;
use App::perlbrew;

my $app = App::perlbrew->new(@ARGV);
$app->run();

__END__

=head1 NAME

perlbrew - Perl environment manager.

=head1 SYNOPSIS

perlbrew command syntax:

    perlbrew <command> [options] [arguments]

Commands:

    init           Initialize perlbrew environment.

    install        Install perl
    uninstall      Uninstall the given installation
    available      List perls available to install
    lib            Manage local::lib directories.
    alias          Give perl installations a new name
    upgrade-perl   Upgrade the current perl

    list           List perl installations
    use            Use the specified perl in current shell
    off            Turn off perlbrew in current shell
    switch         Permanently use the specified perl as default
    switch-off     Permanently turn off perlbrew (revert to system perl)
    exec           exec programs with specified perl enviroments.

    self-install       Install perlbrew itself under PERLBREW_ROOT/bin
    self-upgrade       Upgrade perlbrew itself.

    install-patchperl  Install patchperl
    install-cpanm      Install cpanm, a friendly companion.
    install-ack        Install ack

    download       Download the specified perl distribution tarball.
    mirror         Pick a preferred mirror site
    version        Display version
    help           Read more detailed instructions

Generic command options:

    -q --quiet     Be quiet on informative output message.
    -v --verbose   Tell me more about it.

See `perlbrew help` for the full documentation of perlbrew, or

See `perlbrew help <command>` for detail description of the command.

=head1 CONFIGURATION

=over 4

=item PERLBREW_ROOT

By default, perlbrew builds and installs perls into
C<$ENV{HOME}/perl5/perlbrew> directory. To use a different directory,
set this environment variable in your C<bashrc> to the directory
in your shell RC before sourcing perlbrew's RC.

It is possible to share one perlbrew root with multiple user account
on the same machine. Therefore people do not have to install the same
version of perl over an over. Let's say C</opt/perl5> is the directory
we want to share. All users should be able append this snippet to their
bashrc to make it effective:

    export PERLBREW_ROOT=/opt/perl5
    source ${PERLBREW_ROOT}/etc/bashrc

After doing so, everone's PATH should include C</opt/perl5/bin> and
C</opt/perl5/perls/${PERLBREW_PERL}/bin>. Each user can invoke C<perlbrew
switch> and C<perlbrew use> to independently switch to different perl
environment of their choice. However, only the user with write permission to
C<$PERLBREW_ROOT> may install CPAN modules. This is both good and bad depending
on the working convention of your team.

If you wish to install CPAN modules only for yourself, you should use the C<lib>
command to construct a personal local::lib environment. local::lib environments
are personal, and are not shared between different users. For more detail, read
C<perlbrew help lib> and the documentation of L<local::lib>.

If you want even a cooler module isolation and wish to install CPAN modules used
for just one project, you should use L<carton> for this purpose.

It is also possible to set this variable before installing perlbrew
to make perlbrew install itself under the given PERLBREW_ROOT:

    export PERLBREW_ROOT=/opt/perl5
    curl -kL http://install.perlbrew.pl | bash

After doing this, the perlbrew executable is installed as C</opt/perl5/bin/perlbrew>

=item PERLBREW_HOME

By default, perlbrew stores per-user setting to C<$ENV{HOME}/.perlbrew>
directory. To use a different directory, set this environment variable
in your shell RC before sourcing perlbrew's RC.

In some cases, say, your home directory is on NFS and shared across multiple
machines, you may wish to have several different perlbrew setting
per-machine. To do so, you can use the C<PERLBREW_HOME> environment variable to
tell perlbrew where to look for the initialization file. Here's a brief bash
snippet for the given senario.

    if [ "$(hostname)" == "machine-a" ]; then
        export PERLBREW_HOME=~/.perlbrew-a
    elif [ "$(hostname)" == "machine-b" ]; then
        export PERLBREW_HOME=~/.perlbrew-b
    fi

    source ~/perl5/perlbrew/etc/bashrc

=item PERLBREW_CONFIGURE_FLAGS

This environment variable specify the list of command like flags to pass through
to 'sh Configure'. By default it is '-de -Duserelocatableinc' for versions newer
then or equal to 5.15.5, or '-de' otherwise.

Notice: userelocatableinc is a nice-to-have feature that allows to move
PERLBREW_ROOT around. This building flag was introduced since perl 5.8.9, but
does not play well with perlbrew's path-switching function, not until 5.15.5.
Therefore it is only enabled by default for post-5.15.5.

=back

=head1 COMMAND: INIT

Usage: perlbrew init

The C<init> command should be manually invoked whenever you (the perlbrew user)
upgrade or reinstall perlbrew.

If the upgrade is done with C<self-upgrade> command, or by running the
one-line installer manually, this command is invoked automatically.

=head1 COMMAND: INFO

Usage: perlbrew info

The `info` command dumps a page of handful information for the perlbrew
installation.

=head1 COMMAND: INSTALL

=over 4

=item B<install> [options] perl-<version>

=item B<install> [options] <version>

Build and install the given version of perl.

Version numbers usually look like "5.x.xx", or
"perl-5.xx.x-RCx" for release candidates.

The specified perl is downloaded from the offical CPAN website or from the
mirror site configured before.

To configure mirror site, invoke `mirror` command.

=item B<install> [options]  perl-blead

=item B<install> [options]  blead

A special way to install the blead version of perl, which is downloaded from
this specific URL regardless of mirror settings:

    http://perl5.git.perl.org/perl.git/snapshot/blead.tar.gz

=item B<install>  [options] /path/to/perl/git/checkout/dir

Build and install from the given git checkout dir.


=item B<install>  [options] /path/to/perl-5.14.0.tar.gz

Build and install from the given archive file.

=item B<install>  [options] http://example.com/mirror/perl-5.12.3.tar.gz

Build and install from the given URL. Supported URL schemes are C<http://>,
C<https://>, C<ftp://> and C<file://>.

=back

Options for C<install> command:

    -f --force     Force installation
    -j $n          Parallel buildng and testing. ex. C<perlbrew install -j 5 perl-5.14.2>
    -n --notest    Skip testing

       --as        Install the given version of perl by a name.
                   ex. C<perlbrew install perl-5.6.2 --as legacy-perl>

    -D,-U,-A       Switches passed to perl Configure script.
                   ex. C<perlbrew install perl-5.10.1 -D usemymalloc -U uselargefiles>

    --sitecustomize $filename
                   Specify a file to be installed as sitecustomize.pl

By default, all installations are configured after their name like this:

    sh Configure -de -Duserelocatableinc -Dprefix=$PERLBREW_ROOT/perls/<name>

=head1 COMMAND: UNINSTALL

Usage: perlbrew uninstall <name>

Uninstalls the given perl installation. The name is the installation name as in
the output of `perlbrew list`

=head1 COMMAND: USE

Usage: perlbrew B<use> [perl-<version> | <version> | <name>]

Use the given version perl in current shell. This will not effect newly opened
shells.

Without a parameter, shows the version of perl currently in use.

=head1 COMMAND: SWITCH

Usage: perlbrew switch [ <name> ]

Switch to the given version, and makes it the default for this and all
future terminal sessions.

Without a parameter, shows the version of perl currently selected.

=head1 COMMAND: LIST

Usage: perlbrew list

List the installed versions of perl.

=head1 COMMAND: AVAILABLE

Usage: perlbrew available

List the recently available versions of perl on CPAN.

The list is retrieved from the web page L<http://www.cpan.org/src/README.html>,
and is not the list of *all* perl versions ever releasesed in the past.

NOTICE: This command might be gone in the future and becomes an option of 'list' command.

=head1 COMMAND: OFF

Usage: perlbrew off

Temporarily disable perlbrew in the current shell. Effectively re-enables the
default system Perl, whatever that is.

This command works only if you add the statement of `source $PERLBREW_ROOT/etc/bashrc`
in your shell initialization (bashrc / zshrc).

=head1 COMMAND: SWITCH-OFF

Usage: perlbrew switch-off

Permananently disable perlbrew. Use C<switch> command to re-enable it. Invoke
C<use> command to enable it only in the current shell.

Re-enables the default system Perl, whatever that is.

=head1 COMMAND: ALIAS

Usage: perlbrew alias [-f] create <name> <alias>

    Create an alias for the installation named <name>.

Usage: perlbrew alias [-f] rename <old_alias> <new_alias>

    Rename the alias to a new name.

Usage: perlbrew alias delete <alias>

    Delete the given alias.

=head1 COMMAND: MIRROR

Usage: perlbrew mirror

Run this if you want to choose a specific CPAN mirror to install the
perls from. It will display a list of mirrors for you to pick
from. Hit 'q' to cancel the selection.

=head1 COMMAND: EXEC

Usage: perlbrew exec [--with perl-name[,perl-name...]] <command> <args...>

Execute command for each perl installations, one by one.

For example, run a Hello program:

    perlbrew exec perl -e 'print "Hello from $]\n"'

The output looks like this:

    perl-5.12.2
    ==========
    Hello word from perl-5.012002

    perl-5.13.10
    ==========
    Hello word from perl-5.013010

    perl-5.14.0
    ==========
    Hello word from perl-5.014000

Notice that the command is not executed in parallel.

When C<--with> arugemnt is provided, the command will be only executed with the
specified perl installations. The following command install Moose module into
perl-5.12, regardless the current perl:

    perlbrew exec --with perl-5.12 cpanm Moose

Multiple installation names can be provided:

    perlbrew exec --with perl-5.12,perl-5.12-debug,perl-5.14.2 cpanm Moo

The are splited by either spaces or commas. When spaces are used, it is required
to quote the whole specifiacion as one argument, but then commas can be used in
the installation names:

    perlbrew exec --with '5.12 5.12,debug 5.14.2@nobita @shizuka' cpanm Moo

As demonstrated above, "perl-" prefix can be omitted, and lib names can be
specified too. Lib names can appear without a perl installation name, in such
cases it is assumed to be "current perl".

At the moment, any specified names that fails to be resolved as a real
installation names are silently ignored in the output. Also, the command exit
status are not populated back.

=head1 COMMAND: ENV

Usage: perlbrew env <name>

Low-level command. Invoke this command to see the list of environment
variables that are set by C<perlbrew> itself for shell integration.

The output is something similar to this (if your shell is bash/zsh):

    export PERLBREW_ROOT=/Users/gugod/perl5/perlbrew
    export PERLBREW_VERSION=0.31
    export PERLBREW_PATH=/Users/gugod/perl5/perlbrew/bin:/Users/gugod/perl5/perlbrew/perls/current/bin
    export PERLBREW_PERL=perl-5.14.1

tcsh / csh users shall seens lines of 'setenv' statements instead of `export`.

=head1 COMMAND: SYMLINK-EXECUTABLES

Usage: perlbrew symlink-executables <name>

Low-level command. This command is used to create the C<perl> executable
symbolic link to, say, C<perl5.13.6>. This is only required for
development version of perls.

You don't need to do this unless you have been using old perlbrew to install
perls, and you find youself confused because the perl that you just installed
appears to be missing after invoking `use` or `switch`. perbrew changes its
installation layout since version 0.11, which generades symlinks to executables
in a better way.

If you just upgraded perlbrew (from 0.11 or earlier versions) and C<perlbrew
switch> failed to work after you switch to a development release of perl, say,
perl-5.13.6, run this command:

    perlbrew symlink-executables perl-5.13.6

This essentially creates this symlink:

   ${PERLBREW_ROOT}/perls/perl-5.13.6/bin/perl
   -> ${PERLBREW_ROOT}/perls/perl-5.13.6/bin/perl5.13.6

Newly installed perls, whether they are development versions or not, does not
need manually treatment with this command.

=head1 COMMAND: INSTALL-CPANM

Usage: perlbrew install-cpanm

Install the C<cpanm> standalone executable in C<$PERLBREW_ROOT/bin>.

For more rationale about the existence of this command, read
<http://www.perlbrew.pl/Perlbrew-and-Friends.html>

=head1 COMMAND: INSTALL-PATCHPERL

Usage: perlbrew install-patchperl

Install the C<patchperl> standalone executable in C<$PERLBREW_ROOT/bin>.  This
is automaticall invoked if your perlbrew installation is done with the
installer, but not with cpan.

For more rationale about the existence of this command, read
<http://www.perlbrew.pl/Perlbrew-and-Friends.html>

=head1 COMMAND: SELF-UPGRADE

Usage: perlbrew self-upgrade

This command upgrades Perlbrew to its latest version.

=head1 COMMAND: SELF-INSTALL

Usage: perlbrew self-install

NOTICE: You should not need to run this command in your daily routine.

This command install perlbrew itself to C<$PERLBREW_ROOT/bin>. It is intended
used by the perlbrew installer. However, you may manually do the following to
re-install only the C<perlbrew> executable:

    curl -kL http://get.perlbrew.pl -o perlbrew
    perl ./perlbrew self-install

It is slightly different from running the perlbrew installer because
C<patchperl> is not installed in this case.

=head1 COMMAND: VERSION

Usage: perlbrew version

Show the version of perlbrew.

=head1 COMMAND: LIB

Usage:

    perlbrew lib list
    perlbrew lib create <lib-name>
    perlbrew lib delete <lib-name>

The `lib` command is used to manipulate local::lib roots inside perl
installations. Effectively it is similar to `perl
-Mlocal::lib=/path/to/lib-name`, but a little bit more than just that.

A lib name can be a short name, containing alphanumeric, like 'awesome', or a
full name, prefixed by a perl installation name and a '@' sign, for example,
'perl-5.14.2@awesome'.

Here are some a brief examples to invoke the `lib` command:

    # Create libs by name
    perlbrew lib create nobita
    perlbrew lib create perl-5.12.3@shizuka

    perlbrew list     # See the list of use/switch targets.

    # Activate a lib in current shell.
    perlbrew use perl-5.12.3@nobita
    perlbrew use perl-5.14.2@nobita

    # Activate a lib as default.
    perlbrew switch perl-5.14.2@nobita

    # Delete the lib
    perlbrew lib delete nobita
    perlbrew lib delete perl-5.12.3@shizuka

Short lib names are local to current perl. A lib name 'nobita' can refer to
'perl-5.12.3@nobita' or 'perl-5.14.2@nobita', depending on your current perl.

When C<use>ing or C<switch>ing to a lib, always provide the long name. A simple
rule: the argument to C<use> or C<switch> command should appear in the output of
C<perlbrew list>.

=head1 COMMAND: UPGRADE-PERL

Usage: perlbrew upgrade-perl

Minor Perl releases (ex. 5.x.*) are binary compatible with one another, so this
command offers you the ability to upgrade older perlbrew environments in place.

It upgrades the currently activated perl to its latest released brothers. If you
have a shell with 5.14.0 activated, it upgrades it to 5.14.2.

=head1 COMMAND: DOWNLOAD

Usage:

    perlbrew download perl-5.14.2
    perlbrew download perl-5.16.1
    perlbrew download perl-5.17.3

Download the specified version of perl distribution tarball under C<<
$PERLBREW_ROOT/dists/ >> directory.

=head1 COMMAND: INSTALL-ACK

Usage: perlbrew install-ack

Install the standalone version of C<ack> program under C<$PERLBREW_ROOT/bin>.

=head1 COMMAND: LIST-MODULES

List all installed cpan modules for the current perl.

This command can be used in conjunction with `perlbrew exec` to migrate
your module installation to different perl. The following command
re-installs all modules under perl-5.16.0:

    perlbrew list-modules | perlbrew exec --with perl-5.16.0 cpanm

=head1 UPGRADE NOTES

If you are upgrading C<perlbrew> from 0.16 or ealier versions to a recent
one (0.40-ish), you should do these steps to adjust your perl installations
afterwards (you might need to change the value of PERLBREW_ROOT):

    export PERLBREW_ROOT=${HOME}/perl5/perlbrew
    rm -f $PERLBREW_ROOT/perls/current
    rm -f `find $PERLBREW_ROOT/perls/bin -type l`
    perlbrew symlink-executables
    perlbrew init

Following the instructions on screen to tweak your shell a bit. Then it
should be good.

=head1 SEE ALSO

L<App::perlbrew>, L<App::cpanminus>, L<Devel::PatchPerl>

=cut
