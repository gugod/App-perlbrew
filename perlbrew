#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/perlbrew.pm"} = <<'APP_PERLBREW';
  package App::perlbrew;
  use strict;
  use warnings;
  use 5.008;
  use Getopt::Long ();
  use File::Spec::Functions qw( catfile catdir );
  use File::Path::Tiny;
  use Text::Levenshtein ();
  use FindBin;
  
  our $VERSION = "0.29";
  our $CONF;
  
  our $PERLBREW_ROOT = $ENV{PERLBREW_ROOT} || "$ENV{HOME}/perl5/perlbrew";
  our $PERLBREW_HOME = $ENV{PERLBREW_HOME} || "$ENV{HOME}/.perlbrew";
  
  my $CONF_FILE        = catfile( $PERLBREW_ROOT, 'Conf.pm' );
  
  local $SIG{__DIE__} = sub {
      my $message = shift;
      warn $message;
      exit 1;
  };
  
  sub current_perl {
      my ($self) = @_;
      return $self->env('PERLBREW_PERL')  || ''
  }
  
  sub BASHRC_CONTENT() {
      return "export PERLBREW_BASHRC_VERSION=$VERSION\n\n" . <<'RC';
  [[ -z "$PERLBREW_ROOT" ]] && export PERLBREW_ROOT="$HOME/perl5/perlbrew"
  [[ -z "$PERLBREW_HOME" ]] && export PERLBREW_HOME="$HOME/.perlbrew"
  
  if [[ ! -n "$PERLBREW_SKIP_INIT" ]]; then
      if [[ -f "$PERLBREW_HOME/init" ]]; then
          . "$PERLBREW_HOME/init"
      fi
  fi
  
  __perlbrew_reinit () {
      if [[ ! -d "$PERLBREW_HOME" ]]; then
          mkdir -p "$PERLBREW_HOME"
      fi
  
      echo '# DO NOT EDIT THIS FILE' >| "$PERLBREW_HOME/init"
      command perlbrew env $1 >> "$PERLBREW_HOME/init"
      . "$PERLBREW_HOME/init"
      __perlbrew_set_path
  }
  
  __perlbrew_set_path () {
      [[ -n $(alias perl 2>/dev/null) ]] && unalias perl 2>/dev/null
  
      export PATH_WITHOUT_PERLBREW=$(perl -e 'print join ":", grep { index($_, $ENV{PERLBREW_ROOT}) } split/:/,$ENV{PATH};')
  
      if [[ -z "$PERLBREW_PATH" ]]; then
          export PERLBREW_PATH="$PERLBREW_ROOT/bin"
      fi
  
      export PATH=$PERLBREW_PATH:$PATH_WITHOUT_PERLBREW
  }
  __perlbrew_set_path
  
  perlbrew () {
      local exit_status
      local short_option
      export SHELL
  
      if [[ `echo $1 | awk 'BEGIN{FS=""}{print $1}'` = '-' ]]; then
          short_option=$1
          shift
      else
          short_option=""
      fi
  
      case $1 in
          (use)
              if [[ -z "$2" ]] ; then
                  if [[ -z "$PERLBREW_PERL" ]] ; then
                      echo "Currently using system perl"
                  else
                      echo "Currently using $PERLBREW_PERL"
                  fi
              else
                  code=$(command perlbrew env $2);
                  if [ -z "$code" ]; then
                      exit_status=1
                  else
                      eval $code
                      __perlbrew_set_path
                  fi
              fi
              ;;
  
          (switch)
                if [[ -n "$2" ]] ; then
                    if [[ -x "$PERLBREW_ROOT/perls/$2/bin/perl" ]]; then
                        perlbrew $short_option use $2
                        __perlbrew_reinit $2
                    elif [[ -x "$PERLBREW_ROOT/perls/perl-$2/bin/perl" ]]; then
                        perlbrew $short_option use "perl-$2"
                        __perlbrew_reinit "perl-$2"
                    else
                        echo "$2 is not installed" >&2
                        exit_status=1
                    fi
                else
                    command perlbrew switch
                fi
                ;;
  
          (off)
              unset PERLBREW_PERL
              eval `perlbrew env`
              __perlbrew_set_path
              echo "perlbrew is turned off."
              ;;
  
          (switch-off)
              unset PERLBREW_PERL
              __perlbrew_reinit
              echo "perlbrew is switched off."
              ;;
  
          (*)
              command perlbrew $short_option "$@"
              exit_status=$?
              ;;
      esac
      hash -r
      return ${exit_status:-0}
  }
  
  RC
  
  }
  
  sub CSHRC_CONTENT {
      return "setenv PERLBREW_CSHRC_VERSION $VERSION\n\n" . <<'CSHRC';
  
  if ( $?PERLBREW_HOME == 0 ) then
      setenv PERLBREW_HOME "$HOME/.perlbrew"
  endif
  
  if ( $?PERLBREW_ROOT == 0 ) then
      setenv PERLBREW_ROOT "$HOME/perl5/perlbrew"
  endif
  
  if ( $?PERLBREW_SKIP_INIT == 0 ) then
      if ( -f "$PERLBREW_HOME/init" ) then
          source "PERLBREW_$HOME/init"
      endif
  endif
  
  if ( $?PERLBREW_PATH == 0 ) then
      setenv PERLBREW_PATH "$PERLBREW_ROOT/bin"
  endif
  
  setenv PATH_WITHOUT_PERLBREW `perl -e 'print join ":", grep { index($_, $ENV{PERLBREW_ROOT}) } split/:/,$ENV{PATH};'`
  setenv PATH ${PERLBREW_PATH}:${PATH_WITHOUT_PERLBREW}
  CSHRC
  }
  
  sub mkpath {
      File::Path::Tiny::mk(@_);
  }
  
  sub rmpath {
      File::Path::Tiny::rm(@_)
  }
  
  sub uniq(@) {
      my %a;
      grep { ++$a{$_} == 1 } @_;
  }
  
  {
      my @command;
      sub http_get {
          my ($url, $header, $cb) = @_;
  
          if (ref($header) eq 'CODE') {
              $cb = $header;
              $header = undef;
          }
  
          if (! @command) {
              my @commands = (
                  # curl's --fail option makes the exit code meaningful
                  [qw( curl --silent --location --fail --insecure )],
                  [qw( wget --no-check-certificate --quiet -O - )],
              );
              for my $command (@commands) {
                  my $program = $command->[0];
                  my $code = system("$program --version >/dev/null 2>&1") >> 8;
                  if ($code != 127) {
                      @command = @$command;
                      last;
                  }
              }
              die "You have to install either curl or wget\n"
                  unless @command;
          }
  
          open my $fh, '-|', @command, $url
              or die "open() for '@command $url': $!";
  
          local $/;
          my $body = <$fh>;
          close $fh;
          die 'Page not retrieved; HTTP error code 400 or above.'
              if $command[0] eq 'curl' # Exit code is 22 on 404s etc
              and $? >> 8 == 22; # exit code is packed into $?; see perlvar
          die 'Server issued an error response.'
              if $command[0] eq 'wget' # Exit code is 8 on 404s etc
              and $? >> 8 == 8;
  
          return $cb ? $cb->($body) : $body;
      }
  }
  
  sub new {
      my($class, @argv) = @_;
  
      my %opt = (
          original_argv  => \@argv,
          force => 0,
          quiet => 0,
          D => [],
          U => [],
          A => [],
      );
  
      # build a local @ARGV to allow us to use an older
      # Getopt::Long API in case we are building on an older system
      local (@ARGV) = @argv;
  
      Getopt::Long::Configure(
          'pass_through',
          'no_ignore_case',
          'bundling',
      );
  
      Getopt::Long::GetOptions(
          \%opt,
  
          'force|f!',
          'notest|n!',
          'quiet|q!',
          'verbose|v',
          'as=s',
          'help|h',
          'version',
          # options passed directly to Configure
          'D=s@',
          'U=s@',
          'A=s@',
  
          'j=i'
      )
        or run_command_help(1);
  
      $opt{args} = \@ARGV;
  
      # fix up the effect of 'bundling'
      foreach my $flags (@opt{qw(D U A)}) {
          foreach my $value(@{$flags}) {
              $value =~ s/^=//;
          }
      }
  
      return bless \%opt, $class;
  }
  
  sub env {
      my ($self, $name) = @_;
      return $ENV{$name} if $name;
      return \%ENV;
  }
  
  sub path_with_tilde {
      my ($self, $dir) = @_;
      my $home = $self->env('HOME');
      $dir =~ s/^$home/~/ if $home;
      return $dir;
  }
  
  sub is_shell_csh {
      my ($self) = @_;
      return 1 if $self->env('SHELL') =~ /(t?csh)/;
      return 0;
  }
  
  sub run {
      my($self) = @_;
      $self->run_command($self->args);
  }
  
  sub args {
      my ( $self ) = @_;
      return @{ $self->{args} };
  }
  
  sub commands {
      my ( $self ) = @_;
  
      my $package =  ref $self ? ref $self : $self;
  
      my @commands;
      my $symtable = do {
          no strict 'refs';
          \%{$package . '::'};
      };
  
      foreach my $sym (keys %$symtable) {
          if($sym =~ /^run_command_/) {
              my $glob = $symtable->{$sym};
              if(defined *$glob{CODE}) {
                  $sym =~ s/^run_command_//;
                  $sym =~ s/_/-/g;
                  push @commands, $sym;
              }
          }
      }
  
      return @commands;
  }
  
  sub find_similar_commands {
      my ( $self, $command ) = @_;
      my $SIMILAR_DISTANCE = 6;
  
      my @commands = sort {
          $a->[1] <=> $b->[1]
      } grep {
          defined
      } map {
          my $d =  Text::Levenshtein::fastdistance($_, $command);
  
          ($d < $SIMILAR_DISTANCE) ? [ $_, $d ] : undef
      } $self->commands;
  
      if(@commands) {
          my $best  = $commands[0][1];
          @commands = map { $_->[0] } grep { $_->[1] == $best } @commands;
      }
  
      return @commands;
  }
  
  sub run_command {
      my ( $self, $x, @args ) = @_;
      my $command = $x;
  
      $self->{log_file} ||= "$PERLBREW_ROOT/build.log";
      if($self->{version}) {
          $x = 'version';
      }
      elsif(!$x) {
          $x = 'help';
          @args = (0, $self->{help} ? 2 : 0);
      }
      elsif($x eq 'help') {
          @args = (0, 2) unless @args;
      }
  
      my $s = $self->can("run_command_$x");
      unless ($s) {
          $x =~ y/-/_/;
          $s = $self->can("run_command_$x");
      }
  
      unless($s) {
          my @commands = $self->find_similar_commands($x);
  
          if(@commands > 1) {
              @commands = map { '    ' . $_ } @commands;
              die "Unknown command: `$command`. Did you mean one of the following?\n" . join("\n", @commands) . "\n";
          } elsif(@commands == 1) {
              die "Unknown command: `$command`. Did you mean `$commands[0]`?\n";
          } else {
              die "Unknown command: `$command`. Typo?\n";
          }
      }
  
      # Assume 5.12.3 means perl-5.12.3, for example.
      if ($x =~ /\A(?:switch|use|env)\Z/ and my $name = shift @args) {
          my $fullname = $self->resolve_installation_name($name);
          if ($fullname) {
              unshift @args, $fullname;
          }
          else {
              die "Unknown installation name: $name\n";
          }
      }
      elsif ($x eq 'install') {
          # prepend "perl-" to version number, but only if there is an argument
          $args[0] =~ s/\A((?:\d+\.)*\d+)\Z/perl-$1/
              if @args;
      }
  
      $self->$s(@args);
  }
  
  sub run_command_version {
      my ( $self ) = @_;
      my $package = ref $self;
      my $version = $self->VERSION;
      print <<"VERSION";
  $0  - $package/$version
  VERSION
  }
  
  sub run_command_help {
      my ($self, $status, $verbose) = @_;
  
      if ($self->can("run_command_help_${status}")) {
          $self->can("run_command_help_${status}")->($self);
          exit;
      }
      else {
          require Pod::Usage;
          Pod::Usage::pod2usage(-verbose => $verbose||0, -exitval => (defined $status ? $status : 1));
      }
  }
  
  sub run_command_help_lib {
      print <<'HELP';
  
  The 'lib' command can be used to manage multiple local::lib containers
  inside different perls. Here are some a brief examples:
  
      # Assuming perl-5.14.2 for the following examples.
      perlbrew switch 5.14.2
  
      # Create a local::lib folder named `nobita` inside current perl
      perlbrew lib create nobita
  
      # Create multiple local::lib folders in one command.
      perlbrew lib create nobita shizuka naruto
  
      # Create a local::lib folder named `shizuka` inside perl-5.12.3,
      # ... without activating to perl-5.12.3 first.
      perlbrew lib create perl-5.12.3@shizuka
  
      # Get a list of local::lib folders
      perlbrew lib list
  
      # Activate perl-5.12.3, with the 'nobita' local::lib
      perlbrew use perl-5.12.3@nobita
  
      # Activate perl-5.14.2, with the 'nobita' local::lib
      perlbrew use perl-5.14.2@nobita
  
      # Make perl-5.14.2@nobita the default perl + local::lib setting for new shells.
      perlbrew switch perl-5.14.2@nobita
  
      # Remove libs, notice `shizuka` here means `perl-5.14.2@shizuka`
      perlbrew lib delete perl-5.12.3@nobita shizuka
  
      # Back to a local::lib-less state.
      perlbrew switch perl-5.14.2
  
  HELP
  }
  
  sub run_command_available {
      my ( $self, $dist, $opts ) = @_;
  
      my @available = $self->get_available_perls(@_);
      my @installed = $self->installed_perls(@_);
  
      my $is_installed;
      for my $available (@available) {
          $is_installed = 0;
          for my $installed (@installed) {
              my $name = $installed->{name};
              my $cur  = $installed->{is_current};
              if ( $available eq $installed->{name} ) {
                  $is_installed = 1;
                  last;
              }
          }
          print $is_installed ? 'i ' : '  ', $available, "\n";
      }
  }
  
  sub get_available_perls {
      my ( $self, $dist, $opts ) = @_;
  
      my $url = "http://www.cpan.org/src/README.html";
      my $html = http_get( $url, undef, undef );
  
      unless($html) {
          die "\nERROR: Unable to retrieve the list of perls.\n\n";
      }
  
      my @available_versions;
  
      for ( split "\n", $html ) {
          push @available_versions, $1
            if m|<td><a href="http://www.cpan.org/src/.+?">(.+?)</a></td>|;
      }
      s/\.tar\.gz// for @available_versions;
  
      return @available_versions;
  }
  
  sub run_command_init {
      my $self = shift;
      my $HOME = $self->env('HOME');
  
      mkpath($_) for (
          "$PERLBREW_HOME",
          "$PERLBREW_ROOT/perls", "$PERLBREW_ROOT/dists", "$PERLBREW_ROOT/build", "$PERLBREW_ROOT/etc",
          "$PERLBREW_ROOT/bin"
      );
  
      open BASHRC, "> $PERLBREW_ROOT/etc/bashrc";
      print BASHRC BASHRC_CONTENT;
      close BASHRC;
  
      open CSHRC, "> $PERLBREW_ROOT/etc/cshrc";
      print CSHRC CSHRC_CONTENT;
      close CSHRC;
  
      my ( $shrc, $yourshrc );
      if ( $self->is_shell_csh) {
          $shrc     = 'cshrc';
          $self->env("SHELL") =~ m/(t?csh)/;
          $yourshrc = $1 . "rc";
      }
      else {
          $shrc = $yourshrc = 'bashrc';
      }
  
      $self->run_command_symlink_executables;
  
      my $root_dir = $self->path_with_tilde($PERLBREW_ROOT);
      my $pb_home_dir = $self->path_with_tilde($PERLBREW_HOME);
  
      print <<INSTRUCTION;
  Perlbrew environment initiated, required directories are created under
  
      $root_dir
  
  Paste the following line(s) to the end of your ~/.${yourshrc} and start a
  new shell, perlbrew should be up and fully functional from there:
  
  INSTRUCTION
  
      if ($PERLBREW_HOME ne "$ENV{HOME}/.perlbrew") {
          print "export PERLBREW_HOME=$pb_home_dir\n";
      }
  
      print <<INSTRUCTION;
      source $root_dir/etc/${shrc}
  
  For further instructions, simply run `perlbrew` to see the help message.
  
  Enjoy perlbrew at \$HOME!!
  INSTRUCTION
  
  }
  
  sub run_command_install_perlbrew {
      my $self = shift;
      require File::Copy;
  
      my $executable = $0;
  
      unless (File::Spec->file_name_is_absolute($executable)) {
          $executable = File::Spec->rel2abs($executable);
      }
  
      my $target = catfile($PERLBREW_ROOT, "bin", "perlbrew");
      if ($executable eq $target) {
          print "You are already running the installed perlbrew:\n\n    $executable\n";
          exit;
      }
  
      mkpath("$PERLBREW_ROOT/bin");
      File::Copy::copy($executable, $target);
      chmod(0755, $target);
  
      http_get(
          'https://raw.github.com/gist/962406/5aa30dd2ec33cd9cea42ed2125154dcc1406edbc',
          undef,
          sub {
              my ( $body ) = @_;
  
              my $patchperl_path = catfile($PERLBREW_ROOT, 'bin', 'patchperl');
  
              open my $fh, '>', $patchperl_path or die "Couldn't write patchperl: $!";
              print $fh $body;
              close $fh;
              chmod 0755, $patchperl_path;
          }
      );
  
      my $path = $self->path_with_tilde($target);
  
      print <<HELP;
  The perlbrew is installed as:
  
      $path
  
  You may trash the downloaded $executable from now on.
  
  HELP
  
      $self->run_command_init();
      return;
  }
  
  sub do_install_git {
      my $self = shift;
      my $dist = shift;
  
      my $dist_name;
      my $dist_git_describe;
      my $dist_version;
      require Cwd;
      my $cwd = Cwd::cwd();
      chdir $dist;
      if (`git describe` =~ /v((5\.\d+\.\d+(?:-RC\d)?)(-\d+-\w+)?)$/) {
          $dist_name = 'perl';
          $dist_git_describe = "v$1";
          $dist_version = $2;
      }
      chdir $cwd;
      my $dist_extracted_dir = File::Spec->rel2abs( $dist );
      $self->do_install_this($dist_extracted_dir, $dist_version, "$dist_name-$dist_version");
      return;
  }
  
  sub do_install_url {
      my $self = shift;
      my $dist = shift;
  
      my $dist_name = 'perl';
      # need the period to account for the file extension
      my ($dist_version) = $dist =~ m/-([\d.]+(?:-RC\d+)?|git)\./;
      my ($dist_tarball) = $dist =~ m{/([^/]*)$};
  
      my $dist_tarball_path = "$PERLBREW_ROOT/dists/$dist_tarball";
      my $dist_tarball_url  = $dist;
      $dist = "$dist_name-$dist_version"; # we install it as this name later
  
      if ($dist_tarball_url =~ m/^file/) {
          print "Installing $dist from local archive $dist_tarball_url\n";
          $dist_tarball_url =~ s/^file:\/+/\//;
          $dist_tarball_path = $dist_tarball_url;
      }
      else {
          print "Fetching $dist as $dist_tarball_path\n";
          http_get(
              $dist_tarball_url,
              undef,
              sub {
                  my ($body) = @_;
                  open my $BALL, "> $dist_tarball_path" or die "Couldn't open $dist_tarball_path: $!";
                  print $BALL $body;
                  close $BALL;
              }
          );
      }
  
      my $dist_extracted_path = $self->do_extract_tarball($dist_tarball_path);
      $self->do_install_this($dist_extracted_path, $dist_version, $dist);
      return;
  }
  
  sub do_extract_tarball {
      my $self = shift;
      my $dist_tarball = shift;
  
      # Was broken on Solaris, where GNU tar is probably
      # installed as 'gtar' - RT #61042
      my $tarx =
          ($^O eq 'solaris' ? 'gtar ' : 'tar ') .
          ( $dist_tarball =~ m/bz2$/ ? 'xjf' : 'xzf' );
      my $extract_command = "cd $PERLBREW_ROOT/build; $tarx $dist_tarball";
      die "Failed to extract $dist_tarball" if system($extract_command);
      $dist_tarball =~ s{.*/([^/]+)\.tar\.(?:gz|bz2)$}{$1};
      return "$PERLBREW_ROOT/build/$dist_tarball"; # Note that this is incorrect for blead
  }
  
  sub do_install_blead {
      my $self = shift;
      my $dist = shift;
  
      my $dist_name           = 'perl';
      my $dist_git_describe   = 'blead';
      my $dist_version        = 'blead';
  
      # We always blindly overwrite anything that's already there,
      # because blead is a moving target.
      my $dist_tarball = 'blead.tar.gz';
      my $dist_tarball_path = "$PERLBREW_ROOT/dists/$dist_tarball";
      print "Fetching $dist_git_describe as $dist_tarball_path\n";
      http_get(
          "http://perl5.git.perl.org/perl.git/snapshot/$dist_tarball",
          sub {
              my ($body) = @_;
  
              unless ($body) {
                  die "\nERROR: Failed to download perl-blead tarball.\n\n";
              }
  
              open my $BALL, "> $dist_tarball_path" or die "Couldn't open $dist_tarball_path: $!";
              print $BALL $body;
              close $BALL;
          }
      );
  
      # Returns the wrong extracted dir for blead
      $self->do_extract_tarball($dist_tarball_path);
  
      local *DIRH;
      opendir DIRH, "$PERLBREW_ROOT/build" or die "Couldn't open $PERLBREW_ROOT/build: $!";
      my @contents = readdir DIRH;
      closedir DIRH or warn "Couldn't close $PERLBREW_ROOT/build: $!";
      my @candidates = grep { m/^perl-[0-9a-f]{7,8}$/ } @contents;
      # Use a Schwartzian Transform in case there are lots of dirs that
      # look like "perl-$SHA1", which is what's inside blead.tar.gz,
      # so we stat each one only once.
      @candidates =   map  { $_->[0] }
                      sort { $b->[1] <=> $a->[1] } # descending
                      map  { [ $_, (stat("$PERLBREW_ROOT/build/$_"))[9] ] }
                          @candidates;
      my $dist_extracted_dir = "$PERLBREW_ROOT/build/$candidates[0]"; # take the newest one
      $self->do_install_this($dist_extracted_dir, $dist_version, "$dist_name-$dist_version");
      return;
  }
  
  sub do_install_release {
      my $self = shift;
      my $dist = shift;
  
      my ($dist_name, $dist_version) = $dist =~ m/^(.*)-([\d.]+(?:-RC\d+)?)$/;
      my $mirror = $self->conf->{mirror};
      my $header = $mirror ? { 'Cookie' => "cpan=$mirror->{url}" } : undef;
      my $html = http_get("http://search.cpan.org/dist/$dist", $header);
  
      unless ($html) {
          die "ERROR: Failed to download $dist tarball.";
      }
  
      my ($dist_path, $dist_tarball) =
          $html =~ m[<a href="(/CPAN/authors/id/.+/(${dist}.tar.(gz|bz2)))">Download</a>];
      die "ERROR: Cannot find the tarball for $dist\n"
          if !$dist_path and !$dist_tarball;
  
      my $dist_tarball_path = "${PERLBREW_ROOT}/dists/${dist_tarball}";
      my $dist_tarball_url  = "http://search.cpan.org${dist_path}";
  
      if (-f $dist_tarball_path) {
          print "Use the previously fetched ${dist_tarball}\n";
      }
      else {
          print "Fetching $dist as $dist_tarball_path\n";
          http_get(
              $dist_tarball_url,
              $header,
              sub {
                  my ($body) = @_;
                  open my $BALL, "> $dist_tarball_path";
                  print $BALL $body;
                  close $BALL;
              }
          );
      }
      my $dist_extracted_path = $self->do_extract_tarball($dist_tarball_path);
      $self->do_install_this($dist_extracted_path,$dist_version, $dist);
      return;
  }
  
  sub run_command_install {
      my ( $self, $dist, $opts ) = @_;
      $self->{dist_name} = $dist;
  
      unless ($dist) {
          $self->run_command_install_perlbrew();
          return
      }
  
      my $installation_name = $self->{as} || $dist;
      if ($self->is_installed( $installation_name ) && !$self->{force}) {
          die "\nABORT: $installation_name is already installed.\n\n";
      }
  
      my $help_message = "Unknown installation target \"$dist\", abort.\nPlease see `perlbrew help` for the instruction on using the install command.\n\n";
  
      my ($dist_name, $dist_version) = $dist =~ m/^(.*)-([\d.]+(?:-RC\d+)?|git)$/;
      if (!$dist_name || !$dist_version) { # some kind of special install
          if (-d "$dist/.git") {
              $self->do_install_git($dist);
          }
          if (-f $dist) {
              $self->do_install_archive($dist);
          }
          elsif ($dist =~ m/^(?:https?|ftp|file)/) { # more protocols needed?
              $self->do_install_url($dist);
          }
          elsif ($dist =~ m/(?:perl-)?blead$/) {
              $self->do_install_blead($dist);
          }
          else {
              die $help_message;
          }
      }
      elsif ($dist_name eq 'perl') {
          $self->do_install_release($dist);
      }
      else {
          die $help_message;
      }
  
      return;
  }
  
  sub do_install_archive {
      my $self = shift;
      my $dist_tarball_path = shift;
      my $dist_version;
      my $installation_name;
  
      if ($dist_tarball_path =~ m{perl-?(5.+)\.tar\.(gz|bz2)\Z}) {
          $dist_version = $1;
          $installation_name = "perl-${dist_version}";
      }
  
      unless ($dist_version && $installation_name) {
          die "Unable to determin perl version from archive filename.\n\nThe archive name should look like perl-5.x.y.tar.gz or perl-5.x.y.tar.bz2\n";
      }
  
      my $dist_extracted_path = $self->do_extract_tarball($dist_tarball_path);
      $self->do_install_this($dist_extracted_path, $dist_version, $installation_name);
      return;
  }
  
  sub do_install_this {
      my ($self, $dist_extracted_dir, $dist_version, $as) = @_;
  
      my @d_options = @{ $self->{D} };
      my @u_options = @{ $self->{U} };
      my @a_options = @{ $self->{A} };
      $as = $self->{as} if $self->{as};
  
      unshift @d_options, qq(prefix=$PERLBREW_ROOT/perls/$as);
      push @d_options, "usedevel" if $dist_version =~ /5\.1[13579]|git|blead/;
      print "Installing $dist_extracted_dir into " . $self->path_with_tilde("$PERLBREW_ROOT/perls/$as") . "\n";
      print <<INSTALL if !$self->{verbose};
  
  This could take a while. You can run the following command on another shell to track the status:
  
    tail -f @{[ $self->path_with_tilde($self->{log_file}) ]}
  
  INSTALL
  
      my $configure_flags = '-de';
      # Test via "make test_harness" if available so we'll get
      # automatic parallel testing via $HARNESS_OPTIONS. The
      # "test_harness" target was added in 5.7.3, which was the last
      # development release before 5.8.0.
      my $test_target = "test";
      if ($dist_version =~ /^5\.(\d+)\.(\d+)/
          && ($1 >= 8 || $1 == 7 && $2 == 3)) {
          $test_target = "test_harness";
      }
      local $ENV{TEST_JOBS}=$self->{j}
        if $test_target eq "test_harness" && ($self->{j}||1) > 1;
  
      my $make = "make " . ($self->{j} ? "-j$self->{j}" : "");
      my @install = $self->{notest} ? "make install" : ("make $test_target", "make install");
      @install    = join " && ", @install unless($self->{force});
  
      my $cmd = join ";",
      (
          "cd $dist_extracted_dir",
          "rm -f config.sh Policy.sh",
          "patchperl",
          "sh Configure $configure_flags " .
              join( ' ',
                  ( map { qq{'-D$_'} } @d_options ),
                  ( map { qq{'-U$_'} } @u_options ),
                  ( map { qq{'-A$_'} } @a_options ),
              ),
          $dist_version =~ /^5\.(\d+)\.(\d+)/
              && ($1 < 8 || $1 == 8 && $2 < 9)
                  ? ("$^X -i -nle 'print unless /command-line/' makefile x2p/makefile")
                  : (),
          $make,
          @install
      );
      if($self->{verbose}) {
          $cmd = "($cmd) 2>&1 | tee $self->{log_file}";
          print "$cmd\n" if $self->{verbose};
      } else {
          $cmd = "($cmd) >> '$self->{log_file}' 2>&1 ";
      }
  
  
      delete $ENV{$_} for qw(PERL5LIB PERL5OPT);
  
      if (!system($cmd)) {
          unless (-e "$PERLBREW_ROOT/perls/$as/bin/perl") {
              $self->run_command_symlink_executables($as);
          }
  
          print <<SUCCESS;
  Installed $dist_extracted_dir as $as successfully. Run the following command to switch to it.
  
    perlbrew switch $as
  
  SUCCESS
      }
      else {
          die <<FAIL;
  Installing $dist_extracted_dir failed. See $self->{log_file} to see why.
  If you want to force install the distribution, try:
  
    perlbrew --force install $self->{dist_name}
  
  FAIL
      }
      return;
  }
  
  sub format_perl_version {
      my $self    = shift;
      my $version = shift;
      return sprintf "%d.%d.%d",
        substr( $version, 0, 1 ),
        substr( $version, 2, 3 ),
        substr( $version, 5 );
  
  }
  
  sub installed_perls {
      my $self    = shift;
  
      my @result;
  
      for (<$PERLBREW_ROOT/perls/*>) {
          my ($name) = $_ =~ m/\/([^\/]+$)/;
          my $executable = catfile($_, 'bin', 'perl');
  
          push @result, {
              name        => $name,
              version     => $self->format_perl_version(`$executable -e 'print \$]'`),
              is_current  => ($self->current_perl eq $name) && !$self->env("PERLBREW_LIB"),
              is_external => 0,
              libs => [ $self->local_libs($name) ]
          };
      }
  
      my $current_perl_executable = `which perl`;
      $current_perl_executable =~ s/\n$//;
  
      my $current_perl_executable_version;
      for ( grep { -f $_ && -x $_ } uniq map { s/\/+$//; "$_/perl" } split(":", $self->env('PATH')) ) {
          $current_perl_executable_version =
            $self->format_perl_version(`$_ -e 'print \$]'`);
          push @result, {
              name => $_,
              version => $current_perl_executable_version,
              is_current => $current_perl_executable && ($_ eq $current_perl_executable),
              is_external => 1
          } unless index($_, $PERLBREW_ROOT) == 0;
      }
  
      return @result;
  }
  
  sub local_libs {
      my ($self, $perl_name) = @_;
  
      my @libs = map { substr($_, length($PERLBREW_HOME) + 6) } <$PERLBREW_HOME/libs/*>;
  
      if ($perl_name) {
          @libs = grep { /^$perl_name/ } @libs;
      }
  
      my $current = $self->current_perl . '@' . ($self->env("PERLBREW_LIB") || '');
  
      @libs = map {
          my ($p, $l) = split(/@/, $_);
  
          +{
              name       => $_,
              is_current => $_ eq $current,
              perl_name  => $p,
              lib_name   => $l
          }
      } @libs;
      return @libs;
  }
  
  sub is_installed {
      my ($self, $name) = @_;
      my @installed = grep { !$_->{is_external} } $self->installed_perls;
      return grep { $name eq $_->{name} } @installed;
  }
  
  # Return a hash of PERLBREW_* variables
  sub perlbrew_env {
      my ($self, $name) = @_;
  
      my %env = (
          PERLBREW_VERSION => $VERSION,
          PERLBREW_PATH => "$PERLBREW_ROOT/bin",
          PERLBREW_ROOT => $PERLBREW_ROOT
      );
  
      if ($name) {
          my ($perl_name, $lib_name) = split("@", $name);
          $perl_name = $name unless $lib_name;
  
          if(-d "$PERLBREW_ROOT/perls/$perl_name/bin") {
              $env{PERLBREW_PERL} = $perl_name;
              $env{PERLBREW_PATH} .= ":$PERLBREW_ROOT/perls/$perl_name/bin";
          }
  
          if ($lib_name) {
              require local::lib;
              my $base = "$PERLBREW_HOME/libs/$name";
  
              delete $ENV{PERL_LOCAL_LIB_ROOT};
              my %lib_env = local::lib->build_environment_vars_for($base, 0, 0);
  
              $env{PERLBREW_PATH} = "$base/bin:" . $env{PERLBREW_PATH};
              $env{PERLBREW_LIB}  = $lib_name;
              $env{PERL_MM_OPT}   = $lib_env{PERL_MM_OPT};
              $env{PERL_MB_OPT}   = $lib_env{PERL_MB_OPT};
              $env{PERL5LIB}      = $lib_env{PERL5LIB};
              $env{PERL_LOCAL_LIB_ROOT} = $lib_env{PERL_LOCAL_LIB_ROOT};
          }
          else {
              if ($self->env("PERLBREW_LIB")) {
                  $env{PERLBREW_LIB}        = undef;
                  $env{PERL_MM_OPT}         = undef;
                  $env{PERL_MB_OPT}         = undef;
                  $env{PERL5LIB}            = undef;
                  $env{PERL_LOCAL_LIB_ROOT} = undef;
              }
          }
      }
      else {
          $env{PERLBREW_PERL} = "";
      }
  
      return %env;
  }
  
  sub run_command_list {
      my $self = shift;
  
      for my $i ( $self->installed_perls ) {
          print $i->{is_current} ? '* ': '  ',
              $i->{name},
              (index($i->{name}, $i->{version}) < $[) ? " ($i->{version})" : "",
              "\n";
  
          for my $lib (@{$i->{libs}}) {
              print $lib->{is_current} ? "* " : "  ",
                  $lib->{name}, "\n"
          }
      }
  }
  
  sub run_command_use {
      my $self = shift;
      my $perl = shift;
  
      if ( !$perl ) {
          my $current = $self->current_perl;
          if ($current) {
              print "Currently using $current\n";
          } else {
              print "No version in use; defaulting to system\n";
          }
          return;
      }
  
      my $shell = $self->env('SHELL');
      my $shell_opt = "";
      my %env = ($self->perlbrew_env($perl), PERLBREW_SKIP_INIT => 1);
  
      unless ($ENV{PERLBREW_VERSION}) {
          # The user does not source bashrc/csh in their shell initialization.
          $env{PATH} = $env{PERLBREW_PATH} . ":" . join ":", grep { !/$PERLBREW_ROOT/ } split ":", $ENV{PATH};
      }
  
      my $command = "env ";
      while (my ($k, $v) = each(%env)) {
          $command .= "$k=$v ";
      }
      $command .= " $shell $shell_opt";
  
      print "\nA sub-shell is launched with $perl as the activated perl. Run 'exit' to finish it.\n\n";
  
      exec($command);
  }
  
  sub run_command_switch {
      my ( $self, $dist, $alias ) = @_;
  
      unless ( $dist ) {
          my $current = $self->current_perl;
          printf "Currently switched %s\n",
              ( $current ? "to $current" : 'off' );
          return;
      }
  
      die "Cannot use for alias something that starts with 'perl-'\n"
        if $alias && $alias =~ /^perl-/;
  
      my $vers = $dist;
  
      die "${dist} is not installed\n" unless -d "$PERLBREW_ROOT/perls/${dist}";
  
      local $ENV{PERLBREW_PERL} = $dist;
      my $HOME = $self->env('HOME');
  
      mkpath("${HOME}/.perlbrew");
      system("$0 env $dist > ${HOME}/.perlbrew/init");
  
      print "Switched to $vers. To use it immediately, run this line in this terminal:\n\n    exec @{[ $self->env('SHELL') ]}\n\n";
  }
  
  sub run_command_off {
      my $self = shift;
  
      my $shell = $self->env('SHELL');
  
      $ENV{PERLBREW_PERL} = "";
      my %env = ($self->perlbrew_env, PERLBREW_SKIP_INIT => 1);
  
      my $command = "env ";
      while (my ($k, $v) = each(%env)) {
          $command .= "$k=$v ";
      }
      $command .= " $shell";
  
      print "\nA sub-shell is launched with perlbrew turned off. Run 'exit' to finish it.\n\n";
      exec($command);
  }
  
  sub run_command_switch_off {
      my $self = shift;
      my $pb_home = $self->env("PERLBREW_HOME") || $PERLBREW_HOME;
  
      mkpath($pb_home);
      system("env PERLBREW_PERL= $0 env > ${pb_home}/init");
  
      print "\nperlbrew is switched off. Please exit this shell and start a new one to make it effective.\n";
      print "To immediately make it effective, run this line in this terminal:\n\n    exec @{[ $self->env('SHELL') ]}\n\n";
  }
  
  sub run_command_mirror {
      my($self) = @_;
      print "Fetching mirror list\n";
      my $raw = http_get("http://search.cpan.org/mirror");
  
      unless ($raw) {
          die "\nERROR: Failed to retrive the mirror list.\n\n";
      }
  
      my $found;
      my @mirrors;
      foreach my $line ( split m{\n}, $raw ) {
          $found = 1 if $line =~ m{<select name="mirror">};
          next if ! $found;
          last if $line =~ m{</select>};
          if ( $line =~ m{<option value="(.+?)">(.+?)</option>} ) {
              my $url  = $1;
              my $name = $2;
              $name =~ s/&#(\d+);/chr $1/seg;
              $url =~ s/&#(\d+);/chr $1/seg;
              push @mirrors, { url => $url, name => $name };
          }
      }
  
      require ExtUtils::MakeMaker;
      my $select;
      my $max = @mirrors;
      my $id  = 0;
      while ( @mirrors ) {
          my @page = splice(@mirrors,0,20);
          my $base = $id;
          printf "[% 3d] %s\n", ++$id, $_->{name} for @page;
          my $remaining = $max - $id;
          my $ask = "Select a mirror by number or press enter to see the rest "
                  . "($remaining more) [q to quit, m for manual entry]";
          my $val = ExtUtils::MakeMaker::prompt( $ask );
          if ( ! length $val )  { next }
          elsif ( $val eq 'q' ) { last }
          elsif ( $val eq 'm' ) {
              my $url  = ExtUtils::MakeMaker::prompt("Enter the URL of your CPAN mirror:");
              my $name = ExtUtils::MakeMaker::prompt("Enter a Name: [default: My CPAN Mirror]") || "My CPAN Mirror";
              $select = { name => $name, url => $url };
              last;
          }
          elsif ( not $val =~ /\s*(\d+)\s*/ ) {
              die "Invalid answer: must be 'q', 'm' or a number\n";
          }
          elsif (1 <= $val and $val <= $max) {
              $select = $page[ $val - 1 - $base ];
              last;
          }
          else {
              die "Invalid ID: must be between 1 and $max\n";
          }
      }
      die "You didn't select a mirror!\n" if ! $select;
      print "Selected $select->{name} ($select->{url}) as the mirror\n";
      my $conf = $self->conf;
      $conf->{mirror} = $select;
      $self->_save_conf;
      return;
  }
  
  sub run_command_env {
      my($self, $perl) = @_;
  
      my %env = $self->perlbrew_env($perl);
  
      if ($self->env('SHELL') =~ /(ba|k|z|\/)sh$/) {
          while (my ($k, $v) = each(%env)) {
              if (defined $v) {
                  $v =~ s/(\\")/\\$1/g;
                  print "export $k=\"$v\"\n";
              }
              else {
                  print "unset $k\n";
              }
          }
      }
      else {
          while (my ($k, $v) = each(%env)) {
              if (defined $v) {
                  $v =~ s/(\\")/\\$1/g;
                  print "setenv $k \"$v\"\n";
              }
              else {
                  print "unsetenv $k\n";
              }
          }
      }
  }
  
  sub run_command_symlink_executables {
      my($self, @perls) = @_;
  
      unless (@perls) {
          @perls = map { m{/([^/]+)$} } grep { -d $_ && ! -l $_ } <$PERLBREW_ROOT/perls/*>;
      }
  
      for my $perl (@perls) {
          for my $executable (<$PERLBREW_ROOT/perls/$perl/bin/*>) {
              my ($name, $version) = $executable =~ m/bin\/(.+?)(5\.\d.*)?$/;
              system("ln -fs $executable $PERLBREW_ROOT/perls/$perl/bin/$name") if $version;
          }
      }
  }
  
  sub run_command_install_cpanm {
      my ($self, $perl) = @_;
      my $out = "$PERLBREW_ROOT/bin/cpanm";
  
      if (-f $out && !$self->{force}) {
          require ExtUtils::MakeMaker;
  
          my $ans = ExtUtils::MakeMaker::prompt("\n$out already exists, are you sure to override ? [y/N]", "N");
  
          if ($ans !~ /^Y/i) {
              print "\ncpanm installation skipped.\n\n"
                  unless $self->{quiet};
              exit;
          }
      }
  
      my $body = http_get('https://github.com/miyagawa/cpanminus/raw/master/cpanm');
  
      unless ($body) {
          die "\nERROR: Failed to retrive cpanm executable.\n\n";
      }
  
      mkpath("$PERLBREW_ROOT/bin") unless -d "$PERLBREW_ROOT/bin";
  
      open my $CPANM, '>', $out or die "cannot open file($out): $!";
      print $CPANM $body;
      close $CPANM;
      chmod 0755, $out;
  
      print "\ncpanm is installed to\n\n\t$out\n\n"
          unless $self->{quiet};
  }
  
  sub run_command_install_patchperl {
      my ($self) = @_;
      my $out = "$PERLBREW_ROOT/bin/patchperl";
  
      if (-f $out && !$self->{force}) {
          require ExtUtils::MakeMaker;
  
          my $ans = ExtUtils::MakeMaker::prompt("\n$out already exists, are you sure to override ? [y/N]", "N");
  
          if ($ans !~ /^Y/i) {
              print "\npatchperl installation skipped.\n\n"
                  unless $self->{quiet};
              exit;
          }
      }
  
      my $body = http_get('https://raw.github.com/gugod/patchperl-packing/master/patchperl');
  
      unless ($body) {
          die "\nERROR: Failed to retrive patchperl executable.\n\n";
      }
  
      mkpath("$PERLBREW_ROOT/bin") unless -d "$PERLBREW_ROOT/bin";
      open my $OUT, '>', $out or die "cannot open file($out): $!";
      print $OUT $body;
      close $OUT;
      chmod 0755, $out;
  
      print "\npatchperl is installed to\n\n\t$out\n\n"
          unless $self->{quiet};
  }
  
  sub run_command_self_upgrade {
      my ($self) = @_;
  
      unless(-w $FindBin::Bin) {
          die "Your perlbrew installation appears to be system-wide.  Please upgrade through your package manager.\n";
      }
  
      http_get('https://raw.github.com/gugod/App-perlbrew/master/perlbrew', undef, sub {
          my ( $body ) = @_;
  
          open my $fh, '>', '/tmp/perlbrew' or die "Unable to write perlbrew: $!";
          print $fh $body;
          close $fh;
      });
  
      chmod 0755, '/tmp/perlbrew';
      my $new_version = qx(/tmp/perlbrew version);
      chomp $new_version;
      if($new_version =~ /App::perlbrew\/(\d+\.\d+)$/) {
          $new_version = $1;
      } else {
          die "Unable to detect version of new perlbrew!\n";
      }
      if($new_version <= $VERSION) {
          print "Your perlbrew is up-to-date.\n";
          return;
      }
      system "/tmp/perlbrew", "install";
      unlink "/tmp/perlbrew";
  }
  
  sub run_command_uninstall {
      my ( $self, $target ) = @_;
  
      unless($target) {
          die <<USAGE
  
  Usage: perlbrew uninstall <name>
  
      The name is the installation name as in the output of `perlbrew list`
  
  USAGE
      }
  
      my $dir = "$PERLBREW_ROOT/perls/$target";
  
      if (-l $dir) {
          die "\nThe given name `$target` is an alias, not a real installation. Cannot perform uninstall.\nTo delete the alias, run:\n\n    perlbrew alias delete $target\n\n";
      }
  
      unless(-d $dir) {
          die "'$target' is not installed\n";
      }
      exec 'rm', '-rf', $dir;
  }
  
  sub run_command_exec {
      my $self = shift;
      my @args = @{$self->{original_argv}};
      shift @args;
  
      for my $i ( $self->installed_perls ) {
          next if -l $PERLBREW_ROOT . '/perls/' . $i->{name}; # Skip Aliases
          my %env = $self->perlbrew_env($i->{name});
          next if !$env{PERLBREW_PERL};
  
          local @ENV{ keys %env } = values %env;
          local $ENV{PATH} = join(':', $env{PERLBREW_PATH}, $ENV{PATH});
  
          print "$i->{name}\n==========\n";
          system @args;
          print "\n\n";
          # print "\n<===\n\n\n";
      }
  }
  
  sub run_command_clean {
      my ($self) = @_;
      my @build_dirs = <$PERLBREW_ROOT/build/*>;
  
      for my $dir (@build_dirs) {
          print "Remove $dir\n";
          rmpath($dir);
      }
  
      print "\nDone\n";
  }
  
  sub run_command_alias {
      my ($self, $cmd, $name, $alias) = @_;
  
      if (!$cmd) {
          print <<USAGE;
  
  Usage: perlbrew alias [-f] <action> <name> [<alias>]
  
      perlbrew alias create <name> <alias>
      perlbrew alias delete <alias>
      perlbrew alias rename <old_alias> <new_alias>
  
  USAGE
          return;
      }
  
      unless ( $self->is_installed($name) ) {
          die "\nABORT: The installation `${name}` does not exist.\n\n";
      }
  
      my $path_name  = catfile($PERLBREW_ROOT, "perls", $name);
      my $path_alias = catfile($PERLBREW_ROOT, "perls", $alias) if $alias;
  
      if ($alias && -e $path_alias && !-l $path_alias) {
          die "\nABORT: The installation name `$alias` is not an alias, cannot override.\n\n";
      }
  
      if ($cmd eq 'create') {
          if ( $self->is_installed($alias) && !$self->{force} ) {
              die "\nABORT: The installation `${alias}` already exists. Cannot override.\n\n";
          }
  
  
          unlink($path_alias) if -e $path_alias;
          symlink($path_name, $path_alias);
      }
      elsif($cmd eq 'delete') {
          unless (-l $path_name) {
              die "\nABORT: The installation name `$name` is not an alias, cannot remove.\n\n";
          }
  
          unlink($path_name);
      }
      elsif($cmd eq 'rename') {
          unless (-l $path_name) {
              die "\nABORT: The installation name `$name` is not an alias, cannot rename.\n\n";
          }
  
          if (-l $path_alias && !$self->{force}) {
              die "\nABORT: The alias `$alias` already exists, cannot rename to it.\n\n";
          }
  
          rename($path_name, $path_alias);
      }
      else {
          die "\nERROR: Unrecognized action: `${cmd}`.\n\n";
      }
  }
  
  sub run_command_display_bashrc {
      print BASHRC_CONTENT;
  }
  
  sub run_command_display_cshrc {
      print CSHRC_CONTENT;
  }
  
  sub run_command_lib {
      my ($self, $subcommand, @args) = @_;
      unless ($subcommand) {
          print <<'USAGE';
  
  Usage: perlbrew lib <action> <name> [<name> <name> ...]
  
      perlbrew lib list
      perlbrew lib create nobita
      perlbrew lib create perl-5.14.2@nobita
  
      perlbrew use perl-5.14.2@nobita
      perlbrew lib delete perl-5.12.3@nobita shizuka
  
  USAGE
          return;
      }
  
      my $sub = "run_command_lib_$subcommand";
      if ($self->can($sub)) {
          $self->$sub( @args );
      }
      else {
          print "Unknown command: $subcommand\n";
      }
  }
  
  sub run_command_lib_create {
      my ($self, $name) = @_;
  
      my $fullname = ($name =~ /@/) ? $name : $self->current_perl . '@' . $name;
  
      my $dir = catdir($PERLBREW_HOME,  "libs", $fullname);
  
      if (-d $dir) {
          die "$fullname is already there.\n";
      }
  
      mkpath($dir);
  
      print "lib '$fullname' is created.\n"
          unless $self->{quiet};
  
      return;
  }
  
  sub run_command_lib_delete {
      my ($self, $name) = @_;
  
      my $current  = $self->current_perl . '@' . ($self->env("PERLBREW_LIB") || "");
      my $fullname = ($name =~ /@/) ? $name : $self->current_perl . '@' . $name;
  
      my $dir = catdir($PERLBREW_HOME,  "libs", $fullname);
  
      if (-d $dir) {
  
          if ($fullname eq $current) {
              die "$fullname is currently being used in the current shell, it cannot be deleted.\n";
          }
  
          rmpath($dir);
  
          print "lib '$fullname' is deleted.\n"
              unless $self->{quiet};
      }
      else {
          print "'$fullname' is not in the list of lib\n"
              unless $self->{quiet};
      }
  
      return;
  }
  
  sub run_command_lib_list {
      my ($self) = @_;
  
      my $current = "";
      if ($self->current_perl && $self->env("PERLBREW_LIB")) {
          $current = $self->current_perl . "@" . $self->env("PERLBREW_LIB");
      }
  
      opendir my $dh, catdir($PERLBREW_HOME,  "libs");
      my @libs = grep { !/^\./ } readdir($dh);
  
      for (@libs) {
          print $current eq $_ ? "* " : "  ";
          print "$_\n";
      }
  }
  
  sub resolve_installation_name {
      my ($self, $name) = @_;
      die "App::perlbrew->resolve_installation_name requires one argument." unless $name;
  
      my ($perl_name, $lib_name) = split('@', $name);
      $perl_name = $name unless $lib_name;
  
      if ( $self->is_installed($perl_name) ) {
          return $name;
      }
      elsif ($self->is_installed("perl-${perl_name}")) {
          return "perl-${name}";
      }
  
      return undef;
  }
  
  
  sub conf {
      my($self) = @_;
      $self->_get_conf if ! $CONF;
      return $CONF;
  }
  
  sub _save_conf {
      my($self) = @_;
      require Data::Dumper;
      open my $FH, '>', $CONF_FILE or die "Unable to open conf ($CONF_FILE): $!";
      my $d = Data::Dumper->new([$CONF],['App::perlbrew::CONF']);
      print $FH $d->Dump;
      close $FH;
  }
  
  sub _get_conf {
      my($self) = @_;
  
      if ( ! -e $CONF_FILE ) {
          local $CONF = {} if ! $CONF;
          $self->_save_conf;
      }
  
      open my $FH, '<', $CONF_FILE or die "Unable to open conf ($CONF_FILE): $!\n";
      my $raw = do { local $/; my $rv = <$FH>; $rv };
      close $FH;
  
      my $rv = eval $raw;
      if ( $@ ) {
          warn "Error loading conf: $@\n";
          $CONF = {};
          return;
      }
      $CONF = {} if ! $CONF;
      return;
  }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  App::perlbrew - Manage perl installations in your $HOME
  
  =head1 SYNOPSIS
  
      # Initialize
      perlbrew init
  
      # Pick a preferred CPAN mirror
      perlbrew mirror
  
      # See what is available
      perlbrew available
  
      # Install some Perls
      perlbrew install 5.14.0
      perlbrew install perl-5.8.1
      perlbrew install perl-5.13.6
  
      # See what were installed
      perlbrew list
  
      # Switch perl in the $PATH
      perlbrew switch perl-5.12.2
      perl -v
  
      # Temporarily use another version only in current shell.
      perlbrew use perl-5.8.1
      perl -v
  
      # Or turn it off completely. Useful when you messed up too deep.
      # Or want to go back to the system Perl.
      perlbrew off
  
      # Use 'switch' command to turn it back on.
      perlbrew switch perl-5.12.2
  
      # Exec something with all perlbrew-ed perls
      perlbrew exec perl -E 'say $]'
  
  =head1 DESCRIPTION
  
  perlbrew is a program to automate the building and installation of
  perl in the users HOME. At the moment, it installs everything to
  C<~/perl5/perlbrew>, and requires you to tweak your PATH by including a
  bashrc/cshrc file it provides. You then can benefit from not having
  to run 'sudo' commands to install cpan modules because those are
  installed inside your HOME too. It's a completely separate perl
  environment.
  
  =head1 INSTALLATION
  
  To use C<perlbrew>, it is required to install C<curl> or C<wget>
  first. C<perlbrew> depends on one of this two external commmands to be
  there in order to fetch files from the internet.
  
  The recommended way to install perlbrew is to run this statement in
  your shell:
  
      curl -kL http://xrl.us/perlbrewinstall | bash
  
  After that, C<perlbrew> installs itself to C<~/perl5/perlbrew/bin>,
  and you should follow the instruction on screen to setup your
  C<.bashrc> or C<.cshrc> to put it in your PATH.
  
  The downloaded perlbrew is a self-contained standalone program that
  embeds all non-core modules it uses. It should be runnable with perl
  5.8 or later versions of perl.
  
  This installer also installs a packed version of C<patchperl> to
  C<~/perl5/perlbrew/bin>, which is required to build old perls.
  
  The directory C<~/perl5/perlbrew> will contain all install perl
  executables, libraries, documentations, lib, site_libs. If you need to
  install C<perlbrew>, and the perls it brews, into somewhere else
  because, say, your HOME has limited quota, you can do that by setting
  a C<PERLBREW_ROOT> environment variable before running the installer:
  
      export PERLBREW_ROOT=/opt/perlbrew
      curl -kL http://xrl.us/perlbrewinstall | bash
  
  By default, C<perlbrew> looks for the intialization file that exports
  C<PERLBREW_ROOT> in C<~/.perlbrew/init>.  In some cases (for instance,
  if your home directory is shared across multiple machines), you may
  wish to have several different perlbrew setting per-machine. If so,
  you can use the C<PERLBREW_HOME> environment variable to tell perlbrew
  where to look for the initialization file.
  
   # on machine a
   $ PERLBREW_HOME=~/.perlbrew-a PERLBREW_ROOT=~/perl5/perlbrew-a ./perlbrew install
  
   # on machine b
   $ PERLBREW_HOME=~/.perlbrew-b PERLBREW_ROOT=~/perl5/perlbrew-b ./perlbrew install
  
  If you specify C<PERLBREW_HOME>, you will also need to specify both
  C<PERLBREW_HOME> and C<PERLBREW_ROOT> when you first install perlbrew.
  After that, you'll need to make sure C<PERLBREW_HOME> is exported when
  you log in, before you source C<$PERLBREW_ROOT/etc/bashrc> (or
  C<cshrc>). Example C<.bashrc>:
  
      if [ "$(hostname)" == "machine-a" ]; then
          export PERLBREW_HOME=~/.perlbrew-a
          source ~/perl5/perlbrew-a/etc/bashrc
      elif [ "$(hostname)" == "machine-b" ]; then
          export PERLBREW_HOME=~/.perlbrew-b
          source ~/perl5/perlbrew-b/etc/bashrc
      fi
  
  You may also install perlbrew from CPAN:
  
      cpan App::perlbrew
  
  However, please make sure not to run this with one of the perls brewed
  with perlbrew. It's the best to turn perlbrew off before you run that,
  if you're upgrading.
  
      perlbrew off
      cpan App::perlbrew
  
  You should always use system cpan (like /usr/bin/cpan) to install
  C<App::perlbrew> because then it will be installed under a system PATH
  like C</usr/bin>, which is not affected by perlbrew C<switch> or
  C<use> command.
  
  However, it is still recommended to let C<perlbrew> install itself. It's
  easier, and it works better.
  
  =head1 USAGE
  
  Please read the program usage by running
  
      perlbrew
  
  (No arguments.) To read a more detailed one:
  
      perlbrew -h
  
  =head1 PROJECT DEVELOPMENT
  
  perlbrew project uses github
  L<http://github.com/gugod/App-perlbrew/issues> and RT
  <https://rt.cpan.org/Dist/Display.html?Queue=App-perlbrew> for issue
  tracking. Issues sent to these two systems will eventually be reviewed
  and handled.
  
  =head1 AUTHOR
  
  Kang-min Liu  C<< <gugod@gugod.org> >>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010, 2011 Kang-min Liu C<< <gugod@gugod.org> >>.
  
  =head1 LICENCE
  
  The MIT License
  
  =head1 CONTRIBUTORS
  
  See L<https://github.com/gugod/App-perlbrew/contributors>
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
  =cut
APP_PERLBREW

$fatpacked{"File/Path/Tiny.pm"} = <<'FILE_PATH_TINY';
  package File::Path::Tiny;
  
  $File::Path::Tiny::VERSION = 0.1;
  
  sub mk {
      my ($path,$mask) = @_;
      return 2 if -d $path;
      if (-e $path) { $! = 20;return; }
      $mask ||= '0777'; # Perl::Critic == Integer with leading zeros at ...
      $mask = oct($mask) if substr($mask,0,1) eq '0';
      require File::Spec;
      my ($progressive, @parts) = File::Spec->splitdir($path);
      if (!$progressive) {
          $progressive = File::Spec->catdir($progressive, shift(@parts));
      }
      if(!-d $progressive) {
          mkdir($progressive, $mask) or return;
      }
      for my $part (@parts) {
          $progressive = File::Spec->catdir($progressive,$part);
          if (!-d $progressive) {
              mkdir($progressive, $mask) or return;
          }
      }
      return 1 if -d $path;
      return;
  }
  
  sub rm {
      my ($path) = @_;
      if (-e $path && !-d $path) { $! = 20;return; }
      return 2 if !-d $path;
      opendir(DIR, $path) or return;
      my @contents = grep { $_ ne '.' && $_ ne '..' } readdir(DIR);
      closedir DIR;
      require File::Spec if @contents;
      for my $thing (@contents) {
          my $long = File::Spec->catdir($path, $thing);
          if (!-l $long && -d $long) {
              rm($long) or return;
          }
          else {
              unlink $long or return;
          }
      }
      rmdir($path) or return;
      return 1;
  }
  
  1;
FILE_PATH_TINY

$fatpacked{"Text/Levenshtein.pm"} = <<'TEXT_LEVENSHTEIN';
  package Text::Levenshtein;
  
  use strict;
  use Exporter;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
  
  $VERSION     = '0.04';
  @ISA         = qw(Exporter);
  @EXPORT      = ();
  @EXPORT_OK   = qw(&distance &fastdistance);
  %EXPORT_TAGS = ();
  
  
  sub _min
  {
  	return $_[0] < $_[1]
  		? $_[0] < $_[2] ? $_[0] : $_[2]
  		: $_[1] < $_[2] ? $_[1] : $_[2];
  }
  
  
  sub distance
  {
  	my ($s,@t)=@_;
  
  	my $n=length($s);
  	my @result;
  
  	foreach my $t (@t) {
  		if ($s eq $t) {
  			push @result, 0;
  			next;
  		}
  		my @d;
  		my $cost=0;
  
  		my $m=length($t);
  		push @result,$m and next unless $n;
  		push @result,$n and next unless $m;
  
  		$d[0][0]=0;
  		foreach my $i (1 .. $n) {
  			if ($i != $n && substr($s,$i) eq substr($t,$i)) {
  				push @result,$i;next;
  			}
  			$d[$i][0]=$i;
  		}
  		foreach my $j (1 .. $m) {
  			if ($j != $m && substr($s,$j) eq substr($t,$j)) {
  				push @result,$j;next;
  			}
  			$d[0][$j]=$j;
  		}
  
  		for my $i (1 .. $n) {
  			my $s_i=substr($s,$i-1,1);
  			for my $j (1 .. $m) {
  				$d[$i][$j]=&_min($d[$i-1][$j]+1,
  					 $d[$i][$j-1]+1,
  					 $d[$i-1][$j-1]+($s_i eq substr($t,$j-1,1) ? 0 : 1) )
  			}
  		}
  
  		push @result,$d[$n][$m];
  	}
  
  	if (wantarray) {return @result} else {return $result[0]}
  }
  
  sub fastdistance
  {
  	my $word1 = shift;
  	my $word2 = shift;
  
  	return 0 if $word1 eq $word2;
  	my @d;
  
  	my $len1 = length $word1;
  	my $len2 = length $word2;
  
  	$d[0][0] = 0;
  	for (1 .. $len1) {
  		$d[$_][0] = $_;
  		return $_ if $_!=$len1 && substr($word1,$_) eq substr($word2,$_);
  	}
  	for (1 .. $len2) {
  		$d[0][$_] = $_;
  		return $_ if $_!=$len2 && substr($word1,$_) eq substr($word2,$_);
  	}
  
  	for my $i (1 .. $len1) {
  		my $w1 = substr($word1,$i-1,1);
  		for (1 .. $len2) {
  			$d[$i][$_] = _min($d[$i-1][$_]+1, $d[$i][$_-1]+1, $d[$i-1][$_-1]+($w1 eq substr($word2,$_-1,1) ? 0 : 1));
  		}
  	}
  	return $d[$len1][$len2];
  }
  	
  1;
  
  __END__
  
  =head1 NAME
  
  Text::Levenshtein - An implementation of the Levenshtein edit distance
  
  =head1 SYNOPSIS
  
   use Text::Levenshtein qw(distance);
  
   print distance("foo","four");
   # prints "2"
  
   print fastdistance("foo","four");
   # prints "2" faster
  
   my @words=("four","foo","bar");
   my @distances=distance("foo",@words);
  
   print "@distances";
   # prints "2 0 3"
   
  
  =head1 DESCRIPTION
  
  This module implements the Levenshtein edit distance.
  The Levenshtein edit distance is a measure of the degree of proximity between two strings.
  This distance is the number of substitutions, deletions or insertions ("edits") 
  needed to transform one string into the other one (and vice versa).
  When two strings have distance 0, they are the same.
  A good point to start is: <http://www.merriampark.com/ld.htm>
  
  &fastdistance can be called with two scalars and is faster in most cases.
  
  See also Text::LevenshteinXS on CPAN if you do not require a perl-only implementation.  It
  is extremely faster in nearly all cases.
  
  See also Text::WagnerFischer on CPAN for a configurable edit distance, i.e. for
  configurable costs (weights) for the edits.
  
  
  =head1 AUTHOR
  
  Copyright 2002 Dree Mistrut <F<dree@friul.it>>
  
  This package is free software and is provided "as is" without express
  or implied warranty.  You can redistribute it and/or modify it under 
  the same terms as Perl itself.
  
  =cut
TEXT_LEVENSHTEIN

$fatpacked{"lib/core/only.pm"} = <<'LIB_CORE_ONLY';
  package lib::core::only;
  
  use strict;
  use warnings FATAL => 'all';
  use Config;
  
  sub import {
    @INC = @Config{qw(privlibexp archlibexp)};
    return
  }
  
  =head1 NAME
  
  lib::core::only - Remove all non-core paths from @INC to avoid site/vendor dirs
  
  =head1 SYNOPSIS
  
    use lib::core::only; # now @INC contains only the two core directories
  
  To get only the core directories plus the ones for the local::lib in scope:
  
    $ perl -Mlib::core::only -Mlocal::lib=~/perl5 myscript.pl
  
  To attempt to do a self-contained build (but note this will not reliably
  propagate into subprocesses, see the CAVEATS below):
  
    $ PERL5OPT='-Mlib::core::only -Mlocal::lib=~/perl5' cpan
  
  =head1 DESCRIPTION
  
  lib::core::only is simply a shortcut to say "please reduce my @INC to only
  the core lib and archlib (architecture-specific lib) directories of this perl".
  
  You might want to do this to ensure a local::lib contains only the code you
  need, or to test an L<App::FatPacker|App::FatPacker> tree, or to avoid known
  bad vendor packages.
  
  You might want to use this to try and install a self-contained tree of perl
  modules. Be warned that that probably won't work (see L</CAVEATS>).
  
  This module was extracted from L<local::lib|local::lib>'s --self-contained
  feature, and contains the only part that ever worked. I apologise to anybody
  who thought anything else did.
  
  =head1 CAVEATS
  
  This does B<not> propagate properly across perl invocations like local::lib's
  stuff does. It can't. It's only a module import, so it B<only affects the
  specific perl VM instance in which you load and import() it>.
  
  If you want to cascade it across invocations, you can set the PERL5OPT
  environment variable to '-Mlib::core::only' and it'll sort of work. But be
  aware that taint mode ignores this, so some modules' build and test code
  probably will as well.
  
  You also need to be aware that perl's command line options are not processed
  in order - -I options take effect before -M options, so
  
    perl -Mlib::core::only -Ilib
  
  is unlike to do what you want - it's exactly equivalent to:
  
    perl -Mlib::core::only
  
  If you want to combine a core-only @INC with additional paths, you need to
  add the additional paths using -M options and the L<lib|lib> module:
  
    perl -Mlib::core::only -Mlib=lib
  
    # or if you're trying to test compiled code:
  
    perl -Mlib::core::only -Mblib
  
  For more information on the impossibility of sanely propagating this across
  module builds without help from the build program, see
  L<http://www.shadowcat.co.uk/blog/matt-s-trout/tainted-love> - and for ways
  to achieve the old --self-contained feature's results, look at
  L<App::FatPacker|App::FatPacker>'s tree function, and at
  L<App::cpanminus|cpanm>'s --local-lib-contained feature.
  
  =head1 AUTHOR
  
  Matt S. Trout <mst@shadowcat.co.uk>
  
  =head1 LICENSE
  
  This library is free software under the same terms as perl itself.
  
  =head1 COPYRIGHT
  
  (c) 2010 the lib::core::only L</AUTHOR> as specified above.
  
  =cut
  
  1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = <<'LOCAL_LIB';
  use strict;
  use warnings;
  
  package local::lib;
  
  use 5.008001; # probably works with earlier versions but I'm not supporting them
                # (patches would, of course, be welcome)
  
  use File::Spec ();
  use File::Path ();
  use Carp ();
  use Config;
  
  our $VERSION = '1.008004'; # 1.8.4
  
  our @KNOWN_FLAGS = qw(--self-contained --deactivate --deactivate-all);
  
  sub DEACTIVATE_ONE () { 1 }
  sub DEACTIVATE_ALL () { 2 }
  
  sub INTERPOLATE_ENV () { 1 }
  sub LITERAL_ENV     () { 0 }
  
  sub import {
    my ($class, @args) = @_;
  
    # Remember what PERL5LIB was when we started
    my $perl5lib = $ENV{PERL5LIB} || '';
  
    my %arg_store;
    for my $arg (@args) {
      # check for lethal dash first to stop processing before causing problems
      if ($arg =~ //) {
        die <<'DEATH';
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
      }
      elsif(grep { $arg eq $_ } @KNOWN_FLAGS) {
        (my $flag = $arg) =~ s/--//;
        $arg_store{$flag} = 1;
      }
      elsif($arg =~ /^--/) {
        die "Unknown import argument: $arg";
      }
      else {
        # assume that what's left is a path
        $arg_store{path} = $arg;
      }
    }
  
    if($arg_store{'self-contained'}) {
      die "FATAL: The local::lib --self-contained flag has never worked reliably and the original author, Mark Stosberg, was unable or unwilling to maintain it. As such, this flag has been removed from the local::lib codebase in order to prevent misunderstandings and potentially broken builds. The local::lib authors recommend that you look at the lib::core::only module shipped with this distribution in order to create a more robust environment that is equivalent to what --self-contained provided (although quite possibly not what you originally thought it provided due to the poor quality of the documentation, for which we apologise).\n";
    }
  
    my $deactivating = 0;
    if ($arg_store{deactivate}) {
      $deactivating = DEACTIVATE_ONE;
    }
    if ($arg_store{'deactivate-all'}) {
      $deactivating = DEACTIVATE_ALL;
    }
  
    $arg_store{path} = $class->resolve_path($arg_store{path});
    $class->setup_local_lib_for($arg_store{path}, $deactivating);
  
    for (@INC) { # Untaint @INC
      next if ref; # Skip entry if it is an ARRAY, CODE, blessed, etc.
      m/(.*)/ and $_ = $1;
    }
  }
  
  sub pipeline;
  
  sub pipeline {
    my @methods = @_;
    my $last = pop(@methods);
    if (@methods) {
      \sub {
        my ($obj, @args) = @_;
        $obj->${pipeline @methods}(
          $obj->$last(@args)
        );
      };
    } else {
      \sub {
        shift->$last(@_);
      };
    }
  }
  
  =begin testing
  
  #:: test pipeline
  
  package local::lib;
  
  { package Foo; sub foo { -$_[1] } sub bar { $_[1]+2 } sub baz { $_[1]+3 } }
  my $foo = bless({}, 'Foo');                                                 
  Test::More::ok($foo->${pipeline qw(foo bar baz)}(10) == -15);
  
  =end testing
  
  =cut
  
  sub _uniq {
      my %seen;
      grep { ! $seen{$_}++ } @_;
  }
  
  sub resolve_path {
    my ($class, $path) = @_;
    $class->${pipeline qw(
      resolve_relative_path
      resolve_home_path
      resolve_empty_path
    )}($path);
  }
  
  sub resolve_empty_path {
    my ($class, $path) = @_;
    if (defined $path) {
      $path;
    } else {
      '~/perl5';
    }
  }
  
  =begin testing
  
  #:: test classmethod setup
  
  my $c = 'local::lib';
  
  =end testing
  
  =begin testing
  
  #:: test classmethod
  
  is($c->resolve_empty_path, '~/perl5');
  is($c->resolve_empty_path('foo'), 'foo');
  
  =end testing
  
  =cut
  
  sub resolve_home_path {
    my ($class, $path) = @_;
    return $path unless ($path =~ /^~/);
    my ($user) = ($path =~ /^~([^\/]+)/); # can assume ^~ so undef for 'us'
    my $tried_file_homedir;
    my $homedir = do {
      if (eval { require File::HomeDir } && $File::HomeDir::VERSION >= 0.65) {
        $tried_file_homedir = 1;
        if (defined $user) {
          File::HomeDir->users_home($user);
        } else {
          File::HomeDir->my_home;
        }
      } else {
        if (defined $user) {
          (getpwnam $user)[7];
        } else {
          if (defined $ENV{HOME}) {
            $ENV{HOME};
          } else {
            (getpwuid $<)[7];
          }
        }
      }
    };
    unless (defined $homedir) {
      Carp::croak(
        "Couldn't resolve homedir for "
        .(defined $user ? $user : 'current user')
        .($tried_file_homedir ? '' : ' - consider installing File::HomeDir')
      );
    }
    $path =~ s/^~[^\/]*/$homedir/;
    $path;
  }
  
  sub resolve_relative_path {
    my ($class, $path) = @_;
    $path = File::Spec->rel2abs($path);
  }
  
  =begin testing
  
  #:: test classmethod
  
  local *File::Spec::rel2abs = sub { shift; 'FOO'.shift; };
  is($c->resolve_relative_path('bar'),'FOObar');
  
  =end testing
  
  =cut
  
  sub setup_local_lib_for {
    my ($class, $path, $deactivating) = @_;
  
    my $interpolate = LITERAL_ENV;
    my @active_lls = $class->active_paths;
  
    $path = $class->ensure_dir_structure_for($path);
  
    if (! $deactivating) {
      if (@active_lls && $active_lls[-1] eq $path) {
        exit 0 if $0 eq '-';
        return; # Asked to add what's already at the top of the stack
      } elsif (grep { $_ eq $path} @active_lls) {
        # Asked to add a dir that's lower in the stack -- so we remove it from
        # where it is, and then add it back at the top.
        $class->setup_env_hash_for($path, DEACTIVATE_ONE);
        # Which means we can no longer output "PERL5LIB=...:$PERL5LIB" stuff
        # anymore because we're taking something *out*.
        $interpolate = INTERPOLATE_ENV;
      }
    }
  
    if ($0 eq '-') {
      $class->print_environment_vars_for($path, $deactivating, $interpolate);
      exit 0;
    } else {
      $class->setup_env_hash_for($path, $deactivating);
      @INC = _uniq(split($Config{path_sep}, $ENV{PERL5LIB}), @INC);
    }
  }
  
  sub install_base_bin_path {
    my ($class, $path) = @_;
    File::Spec->catdir($path, 'bin');
  }
  
  sub install_base_perl_path {
    my ($class, $path) = @_;
    File::Spec->catdir($path, 'lib', 'perl5');
  }
  
  sub install_base_arch_path {
    my ($class, $path) = @_;
    File::Spec->catdir($class->install_base_perl_path($path), $Config{archname});
  }
  
  sub ensure_dir_structure_for {
    my ($class, $path) = @_;
    unless (-d $path) {
      warn "Attempting to create directory ${path}\n";
    }
    File::Path::mkpath($path);
    # Need to have the path exist to make a short name for it, so
    # converting to a short name here.
    $path = Win32::GetShortPathName($path) if $^O eq 'MSWin32';
  
    return $path;
  }
  
  sub guess_shelltype {
    my $shellbin = 'sh';
    if(defined $ENV{'SHELL'}) {
        my @shell_bin_path_parts = File::Spec->splitpath($ENV{'SHELL'});
        $shellbin = $shell_bin_path_parts[-1];
    }
    my $shelltype = do {
        local $_ = $shellbin;
        if(/csh/) {
            'csh'
        } else {
            'bourne'
        }
    };
  
    # Both Win32 and Cygwin have $ENV{COMSPEC} set.
    if (defined $ENV{'COMSPEC'} && $^O ne 'cygwin') {
        my @shell_bin_path_parts = File::Spec->splitpath($ENV{'COMSPEC'});
        $shellbin = $shell_bin_path_parts[-1];
           $shelltype = do {
                   local $_ = $shellbin;
                   if(/command\.com/) {
                           'win32'
                   } elsif(/cmd\.exe/) {
                           'win32'
                   } elsif(/4nt\.exe/) {
                           'win32'
                   } else {
                           $shelltype
                   }
           };
    }
    return $shelltype;
  }
  
  sub print_environment_vars_for {
    my ($class, $path, $deactivating, $interpolate) = @_;
    print $class->environment_vars_string_for($path, $deactivating, $interpolate);
  }
  
  sub environment_vars_string_for {
    my ($class, $path, $deactivating, $interpolate) = @_;
    my @envs = $class->build_environment_vars_for($path, $deactivating, $interpolate);
    my $out = '';
  
    # rather basic csh detection, goes on the assumption that something won't
    # call itself csh unless it really is. also, default to bourne in the
    # pathological situation where a user doesn't have $ENV{SHELL} defined.
    # note also that shells with funny names, like zoid, are assumed to be
    # bourne.
  
    my $shelltype = $class->guess_shelltype;
  
    while (@envs) {
      my ($name, $value) = (shift(@envs), shift(@envs));
      $value =~ s/(\\")/\\$1/g if defined $value;
      $out .= $class->${\"build_${shelltype}_env_declaration"}($name, $value);
    }
    return $out;
  }
  
  # simple routines that take two arguments: an %ENV key and a value. return
  # strings that are suitable for passing directly to the relevant shell to set
  # said key to said value.
  sub build_bourne_env_declaration {
    my $class = shift;
    my($name, $value) = @_;
    return defined($value) ? qq{export ${name}="${value}";\n} : qq{unset ${name};\n};
  }
  
  sub build_csh_env_declaration {
    my $class = shift;
    my($name, $value) = @_;
    return defined($value) ? qq{setenv ${name} "${value}"\n} : qq{unsetenv ${name}\n};
  }
  
  sub build_win32_env_declaration {
    my $class = shift;
    my($name, $value) = @_;
    return defined($value) ? qq{set ${name}=${value}\n} : qq{set ${name}=\n};
  }
  
  sub setup_env_hash_for {
    my ($class, $path, $deactivating) = @_;
    my %envs = $class->build_environment_vars_for($path, $deactivating, INTERPOLATE_ENV);
    @ENV{keys %envs} = values %envs;
  }
  
  sub build_environment_vars_for {
    my ($class, $path, $deactivating, $interpolate) = @_;
  
    if ($deactivating == DEACTIVATE_ONE) {
      return $class->build_deactivate_environment_vars_for($path, $interpolate);
    } elsif ($deactivating == DEACTIVATE_ALL) {
      return $class->build_deact_all_environment_vars_for($path, $interpolate);
    } else {
      return $class->build_activate_environment_vars_for($path, $interpolate);
    }
  }
  
  sub build_activate_environment_vars_for {
    my ($class, $path, $interpolate) = @_;
    return (
      PERL_LOCAL_LIB_ROOT => join($Config{path_sep},
                (($ENV{PERL_LOCAL_LIB_ROOT}||()) ?
                  ($interpolate == INTERPOLATE_ENV
                    ? ($ENV{PERL_LOCAL_LIB_ROOT}||())
                    : (($^O ne 'MSWin32') ? '$PERL_LOCAL_LIB_ROOT' 
                      : '%PERL_LOCAL_LIB_ROOT%' ))
                  : ()),
                  $path
              ),
      PERL_MB_OPT => "--install_base ${path}",
      PERL_MM_OPT => "INSTALL_BASE=${path}",
      PERL5LIB => join($Config{path_sep},
                    $class->install_base_arch_path($path),
                    $class->install_base_perl_path($path),
                    (($ENV{PERL5LIB}||()) ?
                      ($interpolate == INTERPOLATE_ENV
                        ? ($ENV{PERL5LIB})
                        : (($^O ne 'MSWin32') ? '$PERL5LIB' : '%PERL5LIB%' ))
                      : ())
                  ),
      PATH => join($Config{path_sep},
                $class->install_base_bin_path($path),
                ($interpolate == INTERPOLATE_ENV
                  ? ($ENV{PATH}||())
                  : (($^O ne 'MSWin32') ? '$PATH' : '%PATH%' ))
               ),
    )
  }
  
  sub active_paths {
    my ($class) = @_;
  
    return () unless defined $ENV{PERL_LOCAL_LIB_ROOT};
    return split /\Q$Config{path_sep}/, $ENV{PERL_LOCAL_LIB_ROOT};
  }
  
  sub build_deactivate_environment_vars_for {
    my ($class, $path, $interpolate) = @_;
  
    my @active_lls = $class->active_paths;
  
    if (!grep { $_ eq $path } @active_lls) {
      warn "Tried to deactivate inactive local::lib '$path'\n";
      return ();
    }
  
    my @new_ll_root = grep { $_ ne $path } @active_lls;
    my @new_perl5lib = grep {
      $_ ne $class->install_base_arch_path($path) &&
      $_ ne $class->install_base_perl_path($path)
    } split /\Q$Config{path_sep}/, $ENV{PERL5LIB};
  
    my %env = (
      PERL_LOCAL_LIB_ROOT => (@new_ll_root ?
        join($Config{path_sep}, @new_ll_root) : undef
      ),
      PERL5LIB => (@new_perl5lib ?
        join($Config{path_sep}, @new_perl5lib) : undef
      ),
      PATH => join($Config{path_sep},
        grep { $_ ne $class->install_base_bin_path($path) }
        split /\Q$Config{path_sep}/, $ENV{PATH}
      ),
    );
  
    # If removing ourselves from the "top of the stack", set install paths to
    # correspond with the new top of stack.
    if ($active_lls[-1] eq $path) {
      if (@active_lls > 1) {
        my $new_top = $active_lls[-2];
        %env = (%env,
          PERL_MB_OPT => "--install_base ${new_top}",
          PERL_MM_OPT => "INSTALL_BASE=${new_top}",
        );
      } else {
        %env = (%env,
          PERL_MB_OPT => undef,
          PERL_MM_OPT => undef,
        );
      }
    }
  
    return %env;
  }
  
  sub build_deact_all_environment_vars_for {
    my ($class, $path, $interpolate) = @_;
  
    my @active_lls = $class->active_paths;
  
    my @new_perl5lib = split /\Q$Config{path_sep}/, $ENV{PERL5LIB};
    my @new_path = split /\Q$Config{path_sep}/, $ENV{PATH};
  
    for my $path (@active_lls) {
      @new_perl5lib = grep {
        $_ ne $class->install_base_arch_path($path) &&
        $_ ne $class->install_base_perl_path($path)
      } @new_perl5lib;
  
      @new_path = grep {
        $_ ne $class->install_base_bin_path($path)
      } @new_path;
    }
  
    my %env = (
      PERL_LOCAL_LIB_ROOT => undef,
      PERL_MM_OPT => undef,
      PERL_MB_OPT => undef,
      PERL5LIB => (@new_perl5lib ?
        join($Config{path_sep}, @new_perl5lib) : undef
      ),
      PATH => join($Config{path_sep}, @new_path),
    );
  
    return %env;
  }
  
  =begin testing
  
  #:: test classmethod
  
  File::Path::rmtree('t/var/splat');
  
  $c->ensure_dir_structure_for('t/var/splat');
  
  ok(-d 't/var/splat');
  
  =end testing
  
  =encoding utf8
  
  =head1 NAME
  
  local::lib - create and use a local lib/ for perl modules with PERL5LIB
  
  =head1 SYNOPSIS
  
  In code -
  
    use local::lib; # sets up a local lib at ~/perl5
  
    use local::lib '~/foo'; # same, but ~/foo
  
    # Or...
    use FindBin;
    use local::lib "$FindBin::Bin/../support";  # app-local support library
  
  From the shell -
  
    # Install LWP and its missing dependencies to the '~/perl5' directory
    perl -MCPAN -Mlocal::lib -e 'CPAN::install(LWP)'
  
    # Just print out useful shell commands
    $ perl -Mlocal::lib
    export PERL_MB_OPT='--install_base /home/username/perl5'
    export PERL_MM_OPT='INSTALL_BASE=/home/username/perl5'
    export PERL5LIB='/home/username/perl5/lib/perl5/i386-linux:/home/username/perl5/lib/perl5'
    export PATH="/home/username/perl5/bin:$PATH"
  
  =head2 The bootstrapping technique
  
  A typical way to install local::lib is using what is known as the
  "bootstrapping" technique.  You would do this if your system administrator
  hasn't already installed local::lib.  In this case, you'll need to install
  local::lib in your home directory. 
  
  If you do have administrative privileges, you will still want to set up your 
  environment variables, as discussed in step 4. Without this, you would still
  install the modules into the system CPAN installation and also your Perl scripts
  will not use the lib/ path you bootstrapped with local::lib.
  
  By default local::lib installs itself and the CPAN modules into ~/perl5.
  
  Windows users must also see L</Differences when using this module under Win32>.
  
  1. Download and unpack the local::lib tarball from CPAN (search for "Download"
  on the CPAN page about local::lib).  Do this as an ordinary user, not as root
  or administrator.  Unpack the file in your home directory or in any other
  convenient location.
  
  2. Run this:
  
    perl Makefile.PL --bootstrap
  
  If the system asks you whether it should automatically configure as much
  as possible, you would typically answer yes.
  
  In order to install local::lib into a directory other than the default, you need
  to specify the name of the directory when you call bootstrap, as follows:
  
    perl Makefile.PL --bootstrap=~/foo
  
  3. Run this: (local::lib assumes you have make installed on your system)
  
    make test && make install
  
  4. Now we need to setup the appropriate environment variables, so that Perl 
  starts using our newly generated lib/ directory. If you are using bash or
  any other Bourne shells, you can add this to your shell startup script this
  way:
  
    echo 'eval $(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)' >>~/.bashrc
  
  If you are using C shell, you can do this as follows:
  
    /bin/csh
    echo $SHELL
    /bin/csh
    perl -I$HOME/perl5/lib/perl5 -Mlocal::lib >> ~/.cshrc
  
  If you passed to bootstrap a directory other than default, you also need to give that as 
  import parameter to the call of the local::lib module like this way:
  
    echo 'eval $(perl -I$HOME/foo/lib/perl5 -Mlocal::lib=$HOME/foo)' >>~/.bashrc
  
  After writing your shell configuration file, be sure to re-read it to get the
  changed settings into your current shell's environment. Bourne shells use 
  C<. ~/.bashrc> for this, whereas C shells use C<source ~/.cshrc>.
  
  If you're on a slower machine, or are operating under draconian disk space
  limitations, you can disable the automatic generation of manpages from POD when
  installing modules by using the C<--no-manpages> argument when bootstrapping:
  
    perl Makefile.PL --bootstrap --no-manpages
  
  To avoid doing several bootstrap for several Perl module environments on the 
  same account, for example if you use it for several different deployed 
  applications independently, you can use one bootstrapped local::lib 
  installation to install modules in different directories directly this way:
  
    cd ~/mydir1
    perl -Mlocal::lib=./
    eval $(perl -Mlocal::lib=./)  ### To set the environment for this shell alone
    printenv                      ### You will see that ~/mydir1 is in the PERL5LIB
    perl -MCPAN -e install ...    ### whatever modules you want
    cd ../mydir2
    ... REPEAT ...
  
  If you are working with several C<local::lib> environments, you may want to
  remove some of them from the current environment without disturbing the others.
  You can deactivate one environment like this (using bourne sh):
  
    eval $(perl -Mlocal::lib=--deactivate,~/path)
  
  which will generate and run the commands needed to remove C<~/path> from your
  various search paths. Whichever environment was B<activated most recently> will
  remain the target for module installations. That is, if you activate
  C<~/path_A> and then you activate C<~/path_B>, new modules you install will go
  in C<~/path_B>. If you deactivate C<~/path_B> then modules will be installed
  into C<~/pathA> -- but if you deactivate C<~/path_A> then they will still be
  installed in C<~/pathB> because pathB was activated later.
  
  You can also ask C<local::lib> to clean itself completely out of the current
  shell's environment with the C<--deactivate-all> option.
  For multiple environments for multiple apps you may need to include a modified
  version of the C<< use FindBin >> instructions in the "In code" sample above.
  If you did something like the above, you have a set of Perl modules at C<<
  ~/mydir1/lib >>. If you have a script at C<< ~/mydir1/scripts/myscript.pl >>,
  you need to tell it where to find the modules you installed for it at C<<
  ~/mydir1/lib >>.
  
  In C<< ~/mydir1/scripts/myscript.pl >>:
  
    use strict;
    use warnings;
    use local::lib "$FindBin::Bin/..";  ### points to ~/mydir1 and local::lib finds lib
    use lib "$FindBin::Bin/../lib";     ### points to ~/mydir1/lib
  
  Put this before any BEGIN { ... } blocks that require the modules you installed.
  
  =head2 Differences when using this module under Win32
  
  To set up the proper environment variables for your current session of
  C<CMD.exe>, you can use this:
  
    C:\>perl -Mlocal::lib
    set PERL_MB_OPT=--install_base C:\DOCUME~1\ADMINI~1\perl5
    set PERL_MM_OPT=INSTALL_BASE=C:\DOCUME~1\ADMINI~1\perl5
    set PERL5LIB=C:\DOCUME~1\ADMINI~1\perl5\lib\perl5;C:\DOCUME~1\ADMINI~1\perl5\lib\perl5\MSWin32-x86-multi-thread
    set PATH=C:\DOCUME~1\ADMINI~1\perl5\bin;%PATH%
    
    ### To set the environment for this shell alone
    C:\>perl -Mlocal::lib > %TEMP%\tmp.bat && %TEMP%\tmp.bat && del %TEMP%\temp.bat
    ### instead of $(perl -Mlocal::lib=./)
  
  If you want the environment entries to persist, you'll need to add then to the
  Control Panel's System applet yourself or use L<App::local::lib::Win32Helper>.
  
  The "~" is translated to the user's profile directory (the directory named for
  the user under "Documents and Settings" (Windows XP or earlier) or "Users"
  (Windows Vista or later)) unless $ENV{HOME} exists. After that, the home
  directory is translated to a short name (which means the directory must exist)
  and the subdirectories are created.
  
  =head1 RATIONALE
  
  The version of a Perl package on your machine is not always the version you
  need.  Obviously, the best thing to do would be to update to the version you
  need.  However, you might be in a situation where you're prevented from doing
  this.  Perhaps you don't have system administrator privileges; or perhaps you
  are using a package management system such as Debian, and nobody has yet gotten
  around to packaging up the version you need.
  
  local::lib solves this problem by allowing you to create your own directory of
  Perl packages downloaded from CPAN (in a multi-user system, this would typically
  be within your own home directory).  The existing system Perl installation is
  not affected; you simply invoke Perl with special options so that Perl uses the
  packages in your own local package directory rather than the system packages.
  local::lib arranges things so that your locally installed version of the Perl
  packages takes precedence over the system installation.
  
  If you are using a package management system (such as Debian), you don't need to
  worry about Debian and CPAN stepping on each other's toes.  Your local version
  of the packages will be written to an entirely separate directory from those
  installed by Debian.  
  
  =head1 DESCRIPTION
  
  This module provides a quick, convenient way of bootstrapping a user-local Perl
  module library located within the user's home directory. It also constructs and
  prints out for the user the list of environment variables using the syntax
  appropriate for the user's current shell (as specified by the C<SHELL>
  environment variable), suitable for directly adding to one's shell
  configuration file.
  
  More generally, local::lib allows for the bootstrapping and usage of a
  directory containing Perl modules outside of Perl's C<@INC>. This makes it
  easier to ship an application with an app-specific copy of a Perl module, or
  collection of modules. Useful in cases like when an upstream maintainer hasn't
  applied a patch to a module of theirs that you need for your application.
  
  On import, local::lib sets the following environment variables to appropriate
  values:
  
  =over 4
  
  =item PERL_MB_OPT
  
  =item PERL_MM_OPT
  
  =item PERL5LIB
  
  =item PATH
  
  PATH is appended to, rather than clobbered.
  
  =back
  
  These values are then available for reference by any code after import.
  
  =head1 CREATING A SELF-CONTAINED SET OF MODULES
  
  See L<lib::core::only> for one way to do this - but note that
  there are a number of caveats, and the best approach is always to perform a
  build against a clean perl (i.e. site and vendor as close to empty as possible).
  
  =head1 OPTIONS
  
  Options are values that can be passed to the C<local::lib> import besides the
  directory to use. They are specified as C<use local::lib '--option'[, path];>
  or C<perl -Mlocal::lib=--option[,path]>.
  
  =head2 --deactivate
  
  Remove the chosen path (or the default path) from the module search paths if it
  was added by C<local::lib>, instead of adding it.
  
  =head2 --deactivate-all
  
  Remove all directories that were added to search paths by C<local::lib> from the
  search paths.
  
  =head1 METHODS
  
  =head2 ensure_dir_structure_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: None
  
  =back
  
  Attempts to create the given path, and all required parent directories. Throws
  an exception on failure.
  
  =head2 print_environment_vars_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: None
  
  =back
  
  Prints to standard output the variables listed above, properly set to use the
  given path as the base directory.
  
  =head2 build_environment_vars_for
  
  =over 4
  
  =item Arguments: $path, $interpolate
  
  =item Return value: \%environment_vars
  
  =back
  
  Returns a hash with the variables listed above, properly set to use the
  given path as the base directory.
  
  =head2 setup_env_hash_for
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: None
  
  =back
  
  Constructs the C<%ENV> keys for the given path, by calling
  L</build_environment_vars_for>.
  
  =head2 active_paths
  
  =over 4
  
  =item Arguments: None
  
  =item Return value: @paths
  
  =back
  
  Returns a list of active C<local::lib> paths, according to the
  C<PERL_LOCAL_LIB_ROOT> environment variable.
  
  =head2 install_base_perl_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $install_base_perl_path
  
  =back
  
  Returns a path describing where to install the Perl modules for this local
  library installation. Appends the directories C<lib> and C<perl5> to the given
  path.
  
  =head2 install_base_arch_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $install_base_arch_path
  
  =back
  
  Returns a path describing where to install the architecture-specific Perl
  modules for this local library installation. Based on the
  L</install_base_perl_path> method's return value, and appends the value of
  C<$Config{archname}>.
  
  =head2 install_base_bin_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $install_base_bin_path
  
  =back
  
  Returns a path describing where to install the executable programs for this
  local library installation. Based on the L</install_base_perl_path> method's
  return value, and appends the directory C<bin>.
  
  =head2 resolve_empty_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $base_path
  
  =back
  
  Builds and returns the base path into which to set up the local module
  installation. Defaults to C<~/perl5>.
  
  =head2 resolve_home_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $home_path
  
  =back
  
  Attempts to find the user's home directory. If installed, uses C<File::HomeDir>
  for this purpose. If no definite answer is available, throws an exception.
  
  =head2 resolve_relative_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $absolute_path
  
  =back
  
  Translates the given path into an absolute path.
  
  =head2 resolve_path
  
  =over 4
  
  =item Arguments: $path
  
  =item Return value: $absolute_path
  
  =back
  
  Calls the following in a pipeline, passing the result from the previous to the
  next, in an attempt to find where to configure the environment for a local
  library installation: L</resolve_empty_path>, L</resolve_home_path>,
  L</resolve_relative_path>. Passes the given path argument to
  L</resolve_empty_path> which then returns a result that is passed to
  L</resolve_home_path>, which then has its result passed to
  L</resolve_relative_path>. The result of this final call is returned from
  L</resolve_path>.
  
  =head1 A WARNING ABOUT UNINST=1
  
  Be careful about using local::lib in combination with "make install UNINST=1".
  The idea of this feature is that will uninstall an old version of a module
  before installing a new one. However it lacks a safety check that the old
  version and the new version will go in the same directory. Used in combination
  with local::lib, you can potentially delete a globally accessible version of a
  module while installing the new version in a local place. Only combine "make
  install UNINST=1" and local::lib if you understand these possible consequences.
  
  =head1 LIMITATIONS
  
  The perl toolchain is unable to handle directory names with spaces in it,
  so you cant put your local::lib bootstrap into a directory with spaces. What
  you can do is moving your local::lib to a directory with spaces B<after> you
  installed all modules inside your local::lib bootstrap. But be aware that you
  cant update or install CPAN modules after the move.
  
  Rather basic shell detection. Right now anything with csh in its name is
  assumed to be a C shell or something compatible, and everything else is assumed
  to be Bourne, except on Win32 systems. If the C<SHELL> environment variable is
  not set, a Bourne-compatible shell is assumed.
  
  Bootstrap is a hack and will use CPAN.pm for ExtUtils::MakeMaker even if you
  have CPANPLUS installed.
  
  Kills any existing PERL5LIB, PERL_MM_OPT or PERL_MB_OPT.
  
  Should probably auto-fixup CPAN config if not already done.
  
  Patches very much welcome for any of the above.
  
  On Win32 systems, does not have a way to write the created environment variables
  to the registry, so that they can persist through a reboot.
  
  =head1 TROUBLESHOOTING
  
  If you've configured local::lib to install CPAN modules somewhere in to your
  home directory, and at some point later you try to install a module with C<cpan
  -i Foo::Bar>, but it fails with an error like: C<Warning: You do not have
  permissions to install into /usr/lib64/perl5/site_perl/5.8.8/x86_64-linux at
  /usr/lib64/perl5/5.8.8/Foo/Bar.pm> and buried within the install log is an
  error saying C<'INSTALL_BASE' is not a known MakeMaker parameter name>, then
  you've somehow lost your updated ExtUtils::MakeMaker module.
  
  To remedy this situation, rerun the bootstrapping procedure documented above.
  
  Then, run C<rm -r ~/.cpan/build/Foo-Bar*>
  
  Finally, re-run C<cpan -i Foo::Bar> and it should install without problems.
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item SHELL
  
  =item COMSPEC
  
  local::lib looks at the user's C<SHELL> environment variable when printing out
  commands to add to the shell configuration file.
  
  On Win32 systems, C<COMSPEC> is also examined.
  
  =back
  
  =head1 SUPPORT
  
  IRC:
  
      Join #local-lib on irc.perl.org.
  
  =head1 AUTHOR
  
  Matt S Trout <mst@shadowcat.co.uk> http://www.shadowcat.co.uk/
  
  auto_install fixes kindly sponsored by http://www.takkle.com/
  
  =head1 CONTRIBUTORS
  
  Patches to correctly output commands for csh style shells, as well as some
  documentation additions, contributed by Christopher Nehren <apeiron@cpan.org>.
  
  Doc patches for a custom local::lib directory, more cleanups in the english
  documentation and a L<german documentation|POD2::DE::local::lib> contributed by Torsten Raudssus
  <torsten@raudssus.de>.
  
  Hans Dieter Pearcey <hdp@cpan.org> sent in some additional tests for ensuring
  things will install properly, submitted a fix for the bug causing problems with
  writing Makefiles during bootstrapping, contributed an example program, and
  submitted yet another fix to ensure that local::lib can install and bootstrap
  properly. Many, many thanks!
  
  pattern of Freenode IRC contributed the beginnings of the Troubleshooting
  section. Many thanks!
  
  Patch to add Win32 support contributed by Curtis Jewell <csjewell@cpan.org>.
  
  Warnings for missing PATH/PERL5LIB (as when not running interactively) silenced
  by a patch from Marco Emilio Poleggi.
  
  Mark Stosberg <mark@summersault.com> provided the code for the now deleted
  '--self-contained' option.
  
  Documentation patches to make win32 usage clearer by
  David Mertens <dcmertens.perl@gmail.com> (run4flat).
  
  Brazilian L<portuguese translation|POD2::PT_BR::local::lib> and minor doc patches contributed by Breno
  G. de Oliveira <garu@cpan.org>.
  
  Improvements to stacking multiple local::lib dirs and removing them from the
  environment later on contributed by Andrew Rodland <arodland@cpan.org>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2007 - 2010 the local::lib L</AUTHOR> and L</CONTRIBUTORS> as
  listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
  
  1;
LOCAL_LIB

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!perl
use strict;
use App::perlbrew;

my $app = App::perlbrew->new(@ARGV);
$app->run();

__END__

=head1 NAME

perlbrew - Perl Environment manager.


=head1 SYNOPSIS

    perlbrew <command> [options] [arguments]

    Commonly used commands:
        init           Initialize perlbrew environment.
        install        Install perl
        uninstall      Uninstall the given installation
        available      List perls available to install
        list           List installed perls
        use            Use the specified perl in current shell
        off            Turn off perlbrew in current shel
        switch         Permanently use the specified perl as default
        switch-off     Permanently turn off perl
        mirror         Pick a preferred mirror site
        version        Display version
        help           Read more detailed instructions

    Examples:
        perlbrew install perl-5.14.1
        perlbrew install 5.12.1

        perlbrew list

        perlbrew use perl-5.12.3
        perlbrew switch perl-5.14.1

=head1 INITIALIZATION

If you never run perlbrew before, or you do not have a C<~/.perlbrew> directory,
you should perform the initialization process by running:

    perlbrew init

This step needs to be done only once.

If latter on you need to change C<$PERLBREW_ROOT>, you (and all other users
who share the same C<$PERLBREW_ROOT> will have to run this again to make it affective.

=head1 COMMANDS

=over 4

=item B<install> [ perl-<version> | <version> ]

Build and install the given version of perl.

Version numbers usually look like "5.x.xx", or
"perl-5.xx.x-RCx" for release candidates.

The specified perl is downloaded from the CPAN website, unless mirror
setting are present.

=item B<install> [ perl-blead | blead ]

A special way to install the blead version of perl, which is downloaded from
this specific URL regardless of mirror settings:

    http://perl5.git.perl.org/perl.git/snapshot/blead.tar.gz

=item B<install> /path/to/perl/git/checkout/dir

Build and install from the given git checkout dir.


=item B<install> /path/to/perl-5.14.0.tar.gz

Build and install from the given archive file.

=item B<install> http://example.com/mirror/perl-5.12.3.tar.gz

Build and install from the given URL. Supported URL schemes are C<http://>,
C<https://>, C<ftp://> and C<file://>.

=item B<uninstall> <target>

Uninstalls the given version.

=item B<use> [perl-<version> | <version> | <name>]

Use the given version perl in current shell. This will not effect newly opened
shells.

Without a parameter, shows the version of perl currently in use.

=item B<switch> [perl-<version> | <version> | <name>]

Switch to the given version, and makes it the default for this and all
future terminal sessions.

Without a parameter, shows the version of perl currently selected.

=item B<list>

List the installed versions of perl.

=item B<available>

List the available versions of perl on CPAN.

=item B<off>

Temporarily disable perlbrew in the current shell.

Re-enables the default system Perl, whatever that is.

=item B<switch-off>

Permananently disable perlbrew. Use C<switch> command to re-enable it.

Re-enables the default system Perl, whatever that is.

=item B<alias> [-f] create <name> <alias>

Create an alias for the installation named <name>.

=item B<alias> [-f] rename <old_alias> <new_alias>

Rename the alias to a new name.

=item B<alias> delete <alias>

Delete the given alias.

=item B<mirror>

Run this if you want to choose a specific CPAN mirror to install the
perls from. It will display a list of mirrors for you to pick
from. Hit 'q' to cancel the selection.

=item B<exec> command

Execute command for all perls.

For example, run a Hello program:

    perlbrew exec perl -e 'print "Hello from $]\n"'

The output depends on your perl installations, and looks like this:

    perl-5.12.2
    ==========
    Hello word from perl-5.012002
    
    perl-5.12.3
    ==========
    Hello word from perl-5.012003
    
    perl-5.13.10
    ==========
    Hello word from perl-5.013010
    
    perl-5.14.0
    ==========
    Hello word from perl-5.014000

Notice that the command is not executed in parallel.

=item B<env> [perl-version]

Low-level command. Use this command to see the list of environment
variables that are set by C<perlbrew> itself for shell integration.

The output is something similar to this (if your shell is bash):

    export PERLBREW_ROOT=/Users/gugod/perl5/perlbrew
    export PERLBREW_VERSION=0.28
    export PERLBREW_PATH=/Users/gugod/perl5/perlbrew/bin:/Users/gugod/perl5/perlbrew/perls/current/bin
    export PERLBREW_PERL=perl-5.14.1

You can also ask for the proper variables for a specific perl version.

=item B<symlink_executables> <perl-version>

Low-level command. This command is used to create the C<perl> executable
symbolic link to, say, C<perl5.13.6>. This is only required for
development version of perls.

You don't need to do this unless you have been using old perlbrew to
install perls. The installation layout is changed since version 0.11.

If you just upgraded perlbrew (from 0.11 or earlier versions) and C<perlbrew
switch> failed to work after you switch to a development release of perl, say,
perl-5.13.6, run this command:

    perlbrew symlink_executables perl-5.13.6

This essentially creates this symlink:

   ${PERLBREW_ROOT}/perls/perl-5.13.6/bin/perl
   -> ${PERLBREW_ROOT}/perls/perl-5.13.6/bin/perl5.13.6

Newly installed perls, whether they are development versions or not, does not
need manually treatment with this command.

=item B<install-cpanm>

Install the C<cpanm> standalone executable in C<$PERLBREW_ROOT/bin>.

For more rationale about the existence of this command, read
<http://www.perlbrew.pl/Perlbrew-and-Friends.html>

=item B<self-upgrade>

This command upgrades Perlbrew to its latest version.

=item B<version>

Show the version of perlbrew.

=back

=head1 OPTIONS

=over 4

=item B<-h| --help>

prints this help.

=item B<-f| --force>

Force installation of a perl.

=item B<-j>

Enable parallel make and test (if supported by the target perl)

  perlbrew install -j 5 perl-5.12.3

=item B<-n| --notest>

Skip the test suite

=item B<-q| --quiet>

Make perlbrew command quieter.

=item B<-v| --verbose>

Make perlbrew command say more.

For C<install> command, this prints the building whole process to STDOUT.

=item B<--as>

Install a given perl under an alias.

    perlbrew install perl-5.6.2 --as legacy-perl

=item B<-D>, B<-U>, B<-A>

pass through switches to the perl Configure script.

    perlbrew install perl-5.10.1 -D usemymalloc -U uselargefiles

=back


=head1 CONFIGURATION

=over 4

=item PERLBREW_ROOT

By default, perlbrew builds and installs perls into
C<$ENV{HOME}/perl5/perlbrew> directory. To use a different directory,
set this environment variable in your C<bashrc> to the directory
before running perlbrew.

=back


=head1 UPGRADE NOTES

If you upgraded C<perlbrew> from version 0.16 or older, you should do
this cleanup your setup. Failure to do so might make the C<use>
command to fail.

Note the version of perl currently selected with C<perlbrew switch>.
Then turn C<perlbrew off>, and switched back again with C<perlbrew
switch previous-perl-version>.


=head1 SEE ALSO

L<App::perlbrew>, L<App::cpanminus>

=cut
